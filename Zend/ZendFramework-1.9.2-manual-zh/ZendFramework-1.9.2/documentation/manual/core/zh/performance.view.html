<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>E.5. View Rendering</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="prev" href="performance.localization.html" title="E.4. Internationalization (i18n) and Localization (l10n)">
<link rel="next" href="copyrights.html" title="附录 F. 版权信息">
<link rel="chapter" href="introduction.html" title="第 1 章 Zend Framework简介">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.amf.html" title="第 3 章 Zend_Amf">
<link rel="chapter" href="zend.application.html" title="第 4 章 Zend_Application">
<link rel="chapter" href="zend.auth.html" title="第 5 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 6 章 Zend_Cache">
<link rel="chapter" href="zend.captcha.html" title="第 7 章 Zend_Captcha">
<link rel="chapter" href="zend.codegenerator.html" title="第 8 章 Zend_CodeGenerator">
<link rel="chapter" href="zend.config.html" title="第 9 章 Zend_Config">
<link rel="chapter" href="zend.config.writer.html" title="第 10 章 Zend_Config_Writer">
<link rel="chapter" href="zend.console.getopt.html" title="第 11 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="zend.date.html" title="第 14 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 15 章 Zend_Db">
<link rel="chapter" href="zend.debug.html" title="第 16 章 Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="第 17 章 Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="第 18 章 Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="第 19 章 Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="第 20 章 Zend_Feed">
<link rel="chapter" href="zend.file.html" title="第 21 章 Zend_File">
<link rel="chapter" href="zend.filter.html" title="第 22 章 Zend_Filter">
<link rel="chapter" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="第 24 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 25 章 Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="第 26 章 Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="第 27 章 Zend_Json">
<link rel="chapter" href="zend.layout.html" title="第 28 章 Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="第 29 章 Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="第 30 章 Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="第 31 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 32 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 33 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 34 章 Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="第 35 章 Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="第 36 章 Zend_Mime">
<link rel="chapter" href="zend.navigation.html" title="第 37 章 Zend_Navigation">
<link rel="chapter" href="zend.openid.html" title="第 38 章 Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="zend.progressbar.html" title="第 41 章 Zend_ProgressBar">
<link rel="chapter" href="zend.queue.html" title="第 42 章 Zend_Queue">
<link rel="chapter" href="zend.reflection.html" title="第 43 章 Zend_Reflection">
<link rel="chapter" href="zend.registry.html" title="第 44 章 Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="第 45 章 Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="第 46 章 Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="第 47 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 48 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 49 章 Zend_Session">
<link rel="chapter" href="zend.soap.html" title="第 50 章 Zend_Soap">
<link rel="chapter" href="zend.tag.html" title="第 51 章 Zend_Tag">
<link rel="chapter" href="zend.test.html" title="第 52 章 Zend_Test">
<link rel="chapter" href="zend.text.html" title="第 53 章 Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="第 54 章 Zend_TimeSync">
<link rel="chapter" href="zend.tool.framework.html" title="第 55 章 Zend_Tool_Framework">
<link rel="chapter" href="zend.tool.project.html" title="第 56 章 Zend_Tool_Project">
<link rel="chapter" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="第 58 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 59 章 Zend_Validate">
<link rel="chapter" href="zend.version.html" title="第 60 章 Zend_Version">
<link rel="chapter" href="zend.view.html" title="第 61 章 Zend_View">
<link rel="chapter" href="zend.wildfire.html" title="第 62 章 Zend_Wildfire">
<link rel="chapter" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="chapter" href="zendx.console.process.unix.html" title="第 64 章 ZendX_Console_Process_Unix">
<link rel="chapter" href="zendx.jquery.html" title="第 65 章 ZendX_JQuery">
<link rel="appendix" href="requirements.html" title="附录 A. 系统需求">
<link rel="appendix" href="coding-standard.html" title="附录 B. Zend Framework 的 PHP 编码标准">
<link rel="appendix" href="doc-standard.html" title="附录 C. Zend Framework Documentation Standard">
<link rel="appendix" href="project-structure.html" title="附录 D. Recommended Project Structure for Zend Framework MVC Applications">
<link rel="appendix" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="appendix" href="copyrights.html" title="附录 F. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="subsection" href="performance.view.html#performance.view.pluginloader" title="E.5.1. How can I speed up resolution of view helpers?">
<link rel="subsection" href="performance.view.html#performance.view.partial" title="E.5.2. How can I speed up view partials?">
<link rel="subsection" href="performance.view.html#performance.view.action" title="E.5.3. How can I speed up calls to the action() view helper?">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">E.5. View Rendering</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="performance.localization.html">上一页</a> </td>
<th width="60%" align="center">附录 E. Zend Framework Performance Guide</th>
<td width="20%" align="right"> <a accesskey="n" href="copyrights.html">下一页</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="performance.view"></a>E.5. View Rendering</h2></div></div></div>
<p>
        When using Zend Framework's <acronym class="acronym">MVC</acronym> layer, chances are you will be using
        <code class="classname">Zend_View</code>. <code class="classname">Zend_View</code> is performs well
        compared to other view or templating engines; since view scripts
        are written in <acronym class="acronym">PHP</acronym>, you do not incur the overhead of compiling custom
        markup to <acronym class="acronym">PHP</acronym>, nor do you need to worry that the compiled
        <acronym class="acronym">PHP</acronym> is not optimized. However, <code class="classname">Zend_View</code> presents
        its own issues: extension is done via overloading (view helpers), and a number of view
        helpers, while carrying out key functionality do so with a performance
        cost.
    </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="performance.view.pluginloader"></a>E.5.1. How can I speed up resolution of view helpers?</h3></div></div></div>
<p>
            Most <code class="classname">Zend_View</code> "methods" are actually provided via
            overloading to the helper system. This provides important flexibility to
            <code class="classname">Zend_View</code>; instead of needing to extend
            <code class="classname">Zend_View</code> and provide all the helper methods you may
            utilize in your application, you can define your helper methods in separate
            classes and consume them at will as if they were direct methods of
            <code class="classname">Zend_View</code>. This keeps the view object itself relatively
            thin, and ensures that objects are created only when needed.
        </p>
<p>
            Internally, <code class="classname">Zend_View</code> uses the <a href="zend.loader.pluginloader.html" title="30.4.  加载插件">PluginLoader</a> to look
            up helper classes. This means that for each helper you call,
            <code class="classname">Zend_View</code> needs to pass the helper name to the
            PluginLoader, which then needs to determine the class name, load the
            class file if necessary, and then return the class name so it may be
            instantiated. Subsequent uses of the helper are much faster, as
            <code class="classname">Zend_View</code> keeps an internal registry of loaded helpers,
            but if you use many helpers, the calls add up.
        </p>
<p>
            The question, then, is: how can you speed up helper resolution?
        </p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="performance.view.pluginloader.cache"></a>E.5.1.1. Use the PluginLoader include file cache</h4></div></div></div>
<p>
                The simplest, cheapest solution is the same as for <a href="performance.classloading.html#performance.classloading.pluginloader" title="E.2.3. How can I speed up plugin loading?">general
                    PluginLoader performance</a>: <a href="">use
                    the PluginLoader include file cache</a>. Anecdotal
                evidence has shown this technique to provide a 25-30%
                performance gain on systems without an opcode cache, and a
                40-65% gain on systems with an opcode cache.
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="performance.view.pluginloader.extend"></a>E.5.1.2. Extend Zend_View to provide often used helper methods</h4></div></div></div>
<p>
                Another solution for those seeking to tune performance even
                further is to extend <code class="classname">Zend_View</code> to manually add the
                helper methods they most use in their application. Such helper
                methods may simply manually instantiate the appropriate helper
                class and proxy to it, or stuff the full helper implementation
                into the method.
            </p>
<pre class="programlisting">
class My_View extends Zend_View
{
    /**
     * @var array Registry of helper classes used
     */
    protected $_localHelperObjects = array();

    /**
     * Proxy to url view helper
     *
     * @param  array $urlOptions Options passed to the assemble method
     *                           of the Route object.
     * @param  mixed $name The name of a Route to use. If null it will
     *                     use the current Route
     * @param  bool $reset Whether or not to reset the route defaults
     *                     with those provided
     * @return string Url for the link href attribute.
     */
    public function url(array $urlOptions = array(), $name = null,
        $reset = false, $encode = true
    ) {
        if (!array_key_exists('url', $this-&gt;_localHelperObjects)) {
            $this-&gt;_localHelperObjects['url'] = new Zend_View_Helper_Url();
            $this-&gt;_localHelperObjects['url']-&gt;setView($view);
        }
        $helper = $this-&gt;_localHelperObjects['url'];
        return $helper-&gt;url($urlOptions, $name, $reset, $encode);
    }

    /**
     * Echo a message
     *
     * Direct implementation.
     *
     * @param  string $string
     * @return string
     */
    public function message($string)
    {
        return "&lt;h1&gt;" . $this-&gt;escape($message) . "&lt;/h1&gt;\n";
    }
}
</pre>
<p>
                Either way, this technique will substantially reduce the
                overhead of the helper system by avoiding calls to the
                PluginLoader entirely, and either benefiting from autoloading or
                bypassing it altogether.
            </p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="performance.view.partial"></a>E.5.2. How can I speed up view partials?</h3></div></div></div>
<p>
            Those who use partials heavily and who profile their applications
            will often immediately notice that the <code class="methodname">partial()</code> view
            helper incurs a lot of overhead, due to the need to clone the view
            object. Is it possible to speed this up?
        </p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="performance.view.partial.render"></a>E.5.2.1. Use partial() only when really necessary</h4></div></div></div>
<p>
                The <code class="methodname">partial()</code> view helper accepts three arguments:
            </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="varname">$name</code>: the name of the view script to render
                </p></li>
<li><p>
                    <code class="varname">$module</code>: the name of the module in which the
                    view script resides; or, if no third argument is provided
                    and this is an array or object, it will be the
                    <code class="varname">$model</code> argument.
                </p></li>
<li><p>
                    <code class="varname">$model</code>: an array or object to pass to the
                    partial representing the clean data to assign to the view.
                </p></li>
</ul></div>
<p>
                The power and use of <code class="methodname">partial()</code> come from the second
                and third arguments. The <code class="varname">$module</code> argument allows
                <code class="methodname">partial()</code> to temporarily add a script path for the
                given module so that the partial view script will resolve to
                that module; the <code class="varname">$model</code> argument allows you to
                explicitly pass variables for use with the partial view.
                If you're not passing either argument, <span class="emphasis"><em>use
                    <code class="methodname">render()</code> instead</em></span>!
            </p>
<p>
                Basically, unless you are actually passing variables to the
                partial and need the clean variable scope, or rendering a view
                script from another <acronym class="acronym">MVC</acronym> module, there is no reason to incur the
                overhead of <code class="methodname">partial()</code>; instead, use
                <code class="classname">Zend_View</code>'s built-in <code class="methodname">render()</code>
                method to render the view script.
            </p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="performance.view.action"></a>E.5.3. How can I speed up calls to the action() view helper?</h3></div></div></div>
<p>
            Version 1.5.0 introduced the <code class="methodname">action()</code> view helper,
            which allows you to dispatch an <acronym class="acronym">MVC</acronym> action and capture its rendered
            content. This provides an important step towards the <acronym class="acronym">DRY</acronym> principle,
            and promotes code reuse. However, as those who profile their
            applications will quickly realize, it, too, is an expensive
            operation. Internally, the <code class="methodname">action()</code> view helper needs
            to clone new request and response objects, invoke the dispatcher,
            invoke the requested controller and action, etc.
        </p>
<p>
            How can you speed it up?
        </p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="performance.view.action.actionstack"></a>E.5.3.1. Use the ActionStack when possible</h4></div></div></div>
<p>
                Introduced at the same time as the <code class="methodname">action()</code> view
                helper, the <a href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.actionstack" title="12.8.4.1. 动作堆栈（助手）">ActionStack</a>
                consists of an action helper and a front controller plugin.
                Together, they allow you to push additional actions to invoke
                during the dispatch cycle onto a stack. If you are calling
                <code class="methodname">action()</code> from your layout view scripts, you may
                want to instead use the ActionStack, and render your views to
                discrete response segments. As an example, you could write a
                <code class="methodname">dispatchLoopStartup()</code> plugin like the following to
                add a login form box to each page:
            </p>
<pre class="programlisting">
class LoginPlugin extends Zend_Controller_Plugin_Abstract
{
    protected $_stack;

    public function dispatchLoopStartup(
        Zend_Controller_Request_Abstract $request
    ) {
        $stack = $this-&gt;getStack();
        $loginRequest = new Zend_Controller_Request_Simple();
        $loginRequest-&gt;setControllerName('user')
                     -&gt;setActionName('index')
                     -&gt;setParam('responseSegment', 'login');
        $stack-&gt;pushStack($loginRequest);
    }

    public function getStack()
    {
        if (null === $this-&gt;_stack) {
            $front = Zend_Controller_Front::getInstance();
            if (!$front-&gt;hasPlugin('Zend_Controller_Plugin_ActionStack')) {
                $stack = new Zend_Controller_Plugin_ActionStack();
                $front-&gt;registerPlugin($stack);
            } else {
                $stack = $front-&gt;getPlugin('ActionStack')
            }
            $this-&gt;_stack = $stack;
        }
        return $this-&gt;_stack;
    }
}
</pre>
<p>
                The <code class="methodname">UserController::indexAction()</code> method might then
                use the <code class="varname">$responseSegment</code> parameter to indicate which
                response segment to render to. In the layout script, you would
                then simply render that response segment:
            </p>
<pre class="programlisting">
&lt;?php $this-&gt;layout()-&gt;login ?&gt;
</pre>
<p>
                While the ActionStack still requires a dispatch cycle, this is
                still cheaper than the <code class="methodname">action()</code> view helper as it
                does not need to clone objects and reset internal state.
                Additionally, it ensures that all pre and post dispatch plugins are
                invoked, which may be of particular concern if you are using
                front controller plugins for handling <acronym class="acronym">ACL</acronym>'s to particular
                actions.
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="performance.view.action.model"></a>E.5.3.2. Favor helpers that query the model over action()</h4></div></div></div>
<p>
                In most cases, using <code class="methodname">action()</code> is simply overkill.
                If you have most business logic nested in your models and are
                simply querying the model and passing the results to a view
                script, it will typically be faster and cleaner to simply write
                a view helper that pulls the model, queries it, and does
                something with that information.
            </p>
<p>
                As an example, consider the following controller action and view
                script:
            </p>
<pre class="programlisting">
class BugController extends Zend_Controller_Action
{
    public function listAction()
    {
        $model = new Bug();
        $this-&gt;view-&gt;bugs = $model-&gt;fetchActive();
    }
}

// bug/list.phtml:
echo "&lt;ul&gt;\n";
foreach ($this-&gt;bugs as $bug) {
    printf("&lt;li&gt;&lt;b&gt;%s&lt;/b&gt;: %s&lt;/li&gt;\n",
        $this-&gt;escape($bug-&gt;id),
        $this-&gt;escape($bug-&gt;summary)
    );
}
echo "&lt;/ul&gt;\n";
</pre>
<p>
                Using <code class="methodname">action()</code>, you would then invoke it with the
                following:
            </p>
<pre class="programlisting">
&lt;?php $this-&gt;action('list', 'bug') ?&gt;
</pre>
<p>
                This could be refactored to a view helper that looks like the
                following:
            </p>
<pre class="programlisting">
class My_View_Helper_BugList extends Zend_View_Helper_Abstract
{
    public function bugList()
    {
        $model = new Bug();
        $html  = "&lt;ul&gt;\n";
        foreach ($model-&gt;fetchActive() as $bug) {
            $html .= sprintf(
                "&lt;li&gt;&lt;b&gt;%s&lt;/b&gt;: %s&lt;/li&gt;\n",
                $this-&gt;view-&gt;escape($bug-&gt;id),
                $this-&gt;view-&gt;escape($bug-&gt;summary)
            );
        }
        $html .= "&lt;/ul&gt;\n";
        return $html;
    }
}
</pre>
<p>
                You would then invoke the helper as follows:
            </p>
<pre class="programlisting">
&lt;?php $this-&gt;bugList() ?&gt;
</pre>
<p>
                This has two benefits: it no longer incurs the overhead of the
                <code class="methodname">action()</code> view helper, and also presents a more
                semantically understandable <acronym class="acronym">API</acronym>.
            </p>
</div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="performance.localization.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="performance.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="copyrights.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">E.4. Internationalization (i18n) and Localization (l10n) </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 附录 F. 版权信息</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
