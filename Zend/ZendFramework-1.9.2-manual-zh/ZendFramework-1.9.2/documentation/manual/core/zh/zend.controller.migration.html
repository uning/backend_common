<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>12.13. 从以前的版本移植</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="prev" href="zend.controller.exceptions.html" title="12.12. MVC 异常">
<link rel="next" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="introduction.html" title="第 1 章 Zend Framework简介">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.amf.html" title="第 3 章 Zend_Amf">
<link rel="chapter" href="zend.application.html" title="第 4 章 Zend_Application">
<link rel="chapter" href="zend.auth.html" title="第 5 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 6 章 Zend_Cache">
<link rel="chapter" href="zend.captcha.html" title="第 7 章 Zend_Captcha">
<link rel="chapter" href="zend.codegenerator.html" title="第 8 章 Zend_CodeGenerator">
<link rel="chapter" href="zend.config.html" title="第 9 章 Zend_Config">
<link rel="chapter" href="zend.config.writer.html" title="第 10 章 Zend_Config_Writer">
<link rel="chapter" href="zend.console.getopt.html" title="第 11 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="zend.date.html" title="第 14 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 15 章 Zend_Db">
<link rel="chapter" href="zend.debug.html" title="第 16 章 Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="第 17 章 Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="第 18 章 Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="第 19 章 Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="第 20 章 Zend_Feed">
<link rel="chapter" href="zend.file.html" title="第 21 章 Zend_File">
<link rel="chapter" href="zend.filter.html" title="第 22 章 Zend_Filter">
<link rel="chapter" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="第 24 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 25 章 Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="第 26 章 Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="第 27 章 Zend_Json">
<link rel="chapter" href="zend.layout.html" title="第 28 章 Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="第 29 章 Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="第 30 章 Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="第 31 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 32 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 33 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 34 章 Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="第 35 章 Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="第 36 章 Zend_Mime">
<link rel="chapter" href="zend.navigation.html" title="第 37 章 Zend_Navigation">
<link rel="chapter" href="zend.openid.html" title="第 38 章 Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="zend.progressbar.html" title="第 41 章 Zend_ProgressBar">
<link rel="chapter" href="zend.queue.html" title="第 42 章 Zend_Queue">
<link rel="chapter" href="zend.reflection.html" title="第 43 章 Zend_Reflection">
<link rel="chapter" href="zend.registry.html" title="第 44 章 Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="第 45 章 Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="第 46 章 Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="第 47 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 48 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 49 章 Zend_Session">
<link rel="chapter" href="zend.soap.html" title="第 50 章 Zend_Soap">
<link rel="chapter" href="zend.tag.html" title="第 51 章 Zend_Tag">
<link rel="chapter" href="zend.test.html" title="第 52 章 Zend_Test">
<link rel="chapter" href="zend.text.html" title="第 53 章 Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="第 54 章 Zend_TimeSync">
<link rel="chapter" href="zend.tool.framework.html" title="第 55 章 Zend_Tool_Framework">
<link rel="chapter" href="zend.tool.project.html" title="第 56 章 Zend_Tool_Project">
<link rel="chapter" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="第 58 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 59 章 Zend_Validate">
<link rel="chapter" href="zend.version.html" title="第 60 章 Zend_Version">
<link rel="chapter" href="zend.view.html" title="第 61 章 Zend_View">
<link rel="chapter" href="zend.wildfire.html" title="第 62 章 Zend_Wildfire">
<link rel="chapter" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="chapter" href="zendx.console.process.unix.html" title="第 64 章 ZendX_Console_Process_Unix">
<link rel="chapter" href="zendx.jquery.html" title="第 65 章 ZendX_JQuery">
<link rel="appendix" href="requirements.html" title="附录 A. 系统需求">
<link rel="appendix" href="coding-standard.html" title="附录 B. Zend Framework 的 PHP 编码标准">
<link rel="appendix" href="doc-standard.html" title="附录 C. Zend Framework Documentation Standard">
<link rel="appendix" href="project-structure.html" title="附录 D. Recommended Project Structure for Zend Framework MVC Applications">
<link rel="appendix" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="appendix" href="copyrights.html" title="附录 F. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="subsection" href="zend.controller.migration.html#zend.controller.migration.fromoneohtoonesix" title="12.13.1.  从 1.5.x 移植到 1.6.0 或更新的版本">
<link rel="subsection" href="zend.controller.migration.html#zend.controller.migration.fromoneohtoonefive" title="12.13.2.  从 1.0.x 到 1.5.0 或更新的版本的移植">
<link rel="subsection" href="zend.controller.migration.html#zend.controller.migration.fromzeroninethree" title="12.13.3.  从 0.9.3 到 1.0.0RC1 或更新的版本的移植">
<link rel="subsection" href="zend.controller.migration.html#zend.controller.migration.fromzeroninetwo" title="12.13.4. 从 0.9.2 移植到 0.9.3 或更新的版本">
<link rel="subsection" href="zend.controller.migration.html#zend.controller.migration.fromzerosix" title="12.13.5. 从 0.6.0 移植到 0.8.0 或更新的版本">
<link rel="subsection" href="zend.controller.migration.html#zend.controller.migration.fromzerotwo" title="12.13.6. 从 0.2.0 或以前的版本移植到 0.6.0">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">12.13. 从以前的版本移植</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.controller.exceptions.html">上一页</a> </td>
<th width="60%" align="center">第 12 章 Zend_Controller</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.currency.html">下一页</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.migration"></a>12.13. 从以前的版本移植</h2></div></div></div>
<p>
        随着时间的推移，MVC组件的API修改了许多。如果你从Zend Framework早期的版本开始使用，遵照下面的方针来移植你的脚本来使用新的架构。
    </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.migration.fromoneohtoonesix"></a>12.13.1.  从 1.5.x 移植到 1.6.0 或更新的版本 </h3></div></div></div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.migration.fromoneohtoonesix.dispatcher"></a>12.13.1.1.  分发器接口修改 </h4></div></div></div>
<p>
                引起我们注意的是<code class="code">Zend_Controller_Front</code> 和
                <code class="code">Zend_Controller_Router_Route_Module</code> 使用的分发器方法不在分发器接口里。
                我们现在添加了下列三个方法来确保定制的分发器可以继续工作：
            </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">getDefaultModule()</code>: 应当返回缺省模块名称。
                </p></li>
<li><p>
                    <code class="code">getDefaultControllerName()</code>: 应当返回缺省控制器的名称。
                </p></li>
<li><p>
                    <code class="code">getDefaultAction()</code>: 应当返回缺省动作的名称。
                </p></li>
</ul></div>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.migration.fromoneohtoonefive"></a>12.13.2.  从 1.0.x 到 1.5.0 或更新的版本的移植 </h3></div></div></div>
<p>
            尽管大部分基本功能和所有有文档的功能保持不变，但有一个特别的 <span class="emphasis"><em> 未披露的（undocumented）</em></span> “功能”发生了改变。
         </p>
<p>
            当写 URLs，文档记载的写驼峰式的动作名称的方法是使用一个字分隔符，这些分隔符缺省是 '.' 或 '-'，也可以在派遣器里配置。派遣器在内部把动作命称都变成小写字母，并使用这些字分隔符通过驼峰规则来重新组合动作方法。 然而，因为 PHP 函数不是大小写敏感，你仍然 <span class="emphasis"><em> 可以 </em></span> 使用驼峰规则来写 URLs，派遣器将解析它们到同一位置。 例如：'camel-cased' 将成为 'camelCasedAction' ，而 'camelCased'  将成为 'camelcasedAction' ，然而，根据 PHP 的大小写敏感性，它们都将执行同一方法。
        </p>
<p>
            问题是当用视图解析器（ViewRenderer）解析(resolving)视图脚本的时候：规范的，文档记载的方法是所有的字分隔符被转换成短横线，所有的字母变小写，这在动作和视图脚本之间建立了一个语义联系，并且标准化确保能找到脚本。然而，如果调用动作 'camelCased' 并确实被解析，字分隔符不再存在，并且视图解析器（ViewRenderer）尝试解析到不同的地方 － 'camelcased.phtml'  而不是 'camel-cased.phtml' 。
        </p>
<p>
            有些开发者无意中依赖这个“功能”。在 1.5.0 中有若干修改，使得视图解析器（ViewRenderer）不再解析这些路径，现在强制语义联系。 首先，派遣器现在强制动作名大小写敏感，那意味着在 url 指向动作而使用的驼峰命名和使用字分隔符（如，'camel-casing'）不再解析到同一方法。这导致视图解析器（ViewRenderer）当解析视图教本时只考虑字分隔符动作。
        </p>
<p>
            如果你是依赖这个“功能”，有下列解决办法：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    最好的办法：修改视图脚本的名称。好处是：向前兼容。坏处是：如果你的视图脚本很多，那是一个很大的工作量。
            </p></li>
<li>
<p>
                    第二好的办法：视图解析器（ViewRenderer）现在给 <code class="code">Zend_Filter_Inflector</code> 代表视图脚本解析，可以修改变形器（inflector）的规则，使之不再用短横线作为动作名称中的分隔符：
                </p>
<pre class="programlisting">
$viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper('viewRenderer');
$inflector = $viewRenderer-&gt;getInflector();
$inflector-&gt;setFilterRule(':action', array(
    new Zend_Filter_PregReplace(
        '#[^a-z0-9' . preg_quote(DIRECTORY_SEPARATOR, '#') . ']+#i',
        ''
    ),
    'StringToLower'
));


                </pre>
<p>
                    上面的代码修改变形器使之不再使用短横线作为字分隔符，如果你<span class="emphasis"><em>确实</em></span>也想用驼峰命名实际的视图脚本，可能要删除 'StringToLower'过滤器。
                </p>
<p>
                    如果修改视图脚本名很无聊和浪费时间，这是你最好的选择除非你有时间来做。
                </p>
</li>
<li>
<p>
                    最不希望的办法：你可以强制派遣器用新的前端控制器标志－'useCaseSensitiveActions'来派遣驼峰命名的动作：
                </p>
<pre class="programlisting">
$front-&gt;setParam('useCaseSensitiveActions', true);


                </pre>
<p>
                    这将允许你再 url 中使用驼峰命名并且仍把它解析到和用字分隔符命名的同一动作。然而，这将意味着原有的问题接踵而来，你将可能使用上述第二种办法以确保可靠工作。
                 </p>
<p>
                    注：那个标志（flag)的用法将提示这个用法将退出舞台。
                </p>
</li>
</ul></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.migration.fromzeroninethree"></a>12.13.3.  从 0.9.3 到 1.0.0RC1 或更新的版本的移植 </h3></div></div></div>
<p>
            在1.0.0RC1中的主要变化是<a href="zend.controller.plugins.html#zend.controller.plugins.standard.errorhandler" title="12.10.5.2. Zend_Controller_Plugin_ErrorHandler">ErrorHandler</a>插件的缺省激活 和 <a href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.viewrenderer" title="12.8.4.7. ViewRenderer">ViewRenderer</a>的动作助手的简介。请阅读整个的文档来看它们是如何工作的和对你的应用程序有什么影响。
        </p>
<p>
            在<code class="code">postDispatch()</code>期间，<code class="code">ErrorHandler</code>插件检查异常，并转发到一个特定的错误管理控制器。你需要包含这样一个控制器在你的程序中，可以通过设置前端控制器参数<code class="code">noErrorHandler</code>来禁止它：
        </p>
<pre class="programlisting">
$front-&gt;setParam('noErrorHandler', true);

        </pre>
<p>
            基于当前版本，<code class="code">ViewRenderer</code>动作助手使视图注入到动作控制器和视图脚本的自动调用自动化。你可能遇到的主要问题是如果你有没有调用视图脚本的动作并且不转发也不重定向，因为<code class="code">ViewRenderer</code>将基于动作名来尝试调用一个视图脚本。
        </p>
<p>
            有若干策略你可以用来更新你的代码。短期，你可以在派遣之前全局地在前端控制器引导文件禁止<code class="code">ViewRenderer</code>：
        </p>
<pre class="programlisting">
// Assuming $front is an instance of Zend_Controller_Front
$front-&gt;setParam('noViewRenderer', true);

        </pre>
<p>
            然而，这不是一个好的长期策略，因为它意味着最大可能你要写更多的代码。
        </p>
<p>
            当你准备好开始使用<code class="code">ViewRenderer</code>功能，有若干事情需要在控制器代码里寻找。首先，看看动作方法（以'Action'结尾的方法）都在干什么。如果下面任何事情都没有发生，你需要修改：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>Calls to <code class="code">$this-&gt;render()</code></p></li>
<li><p>Calls to <code class="code">$this-&gt;_forward()</code></p></li>
<li><p>Calls to <code class="code">$this-&gt;_redirect()</code></p></li>
<li><p>Calls to the <code class="code">Redirector</code> action helper</p></li>
</ul></div>
<p>
            最容易的修改就是为那个方法禁止auto-rendering：
        </p>
<pre class="programlisting">
$this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender();

        </pre>
<p>
            如果你发现没有动作方法调用，转发或重定向，你可能需要把上面一行放到<code class="code">preDispatch()</code> 或 <code class="code">init()</code>方法：
        </p>
<pre class="programlisting">
public function preDispatch()
{
    // disable view script autorendering
    $this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender()
    // .. do other things...
}

        </pre>
<p>
            如果你调用<code class="code">render()</code>并使用<a href="zend.controller.modular.html" title="12.11. 使用传统的模块目录结构">传统模块目录结构</a>，你将想修改你的代码去利用自动调用：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    如果在一个单个的动作里调用多个视图脚本，你不需要修改任何事情。
                </p></li>
<li><p>
                    如果不带参数调用<code class="code">render()</code>，你可以删除它。
                </p></li>
<li><p>
                    如果带参数调用<code class="code">render()</code>，并以后不做任何处理或调用多个视图脚本，你可以修改这些调用去读<code class="code">$this-&gt;_helper-&gt;viewRenderer()</code>。
                </p></li>
</ul></div>
<p>
            如果你不使用传统模块目录结构，有很多方法来设置视图基本路径和脚本路径参数，这样你可以使用<code class="code">ViewRenderer</code>。请阅读<a href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.viewrenderer" title="12.8.4.7. ViewRenderer">ViewRenderer 文档</a>中关于这些方法的信息。
        </p>
<p>
            如果你使用注册表中的视图对象，或定制你的视图对象，或使用不同的视图实现，你需要注入<code class="code">ViewRenderer</code>。这很容易地在任何时候完成。
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
<p>
                    在派遣前端控制器实例之前：
                </p>
<pre class="programlisting">
// Assuming $view has already been defined
$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer($view);
Zend_Controller_Action_HelperBroker::addHelper($viewRenderer);

                </pre>
</li>
<li>
<p>
                    在引导过程中的任何时候：
                </p>
<pre class="programlisting">
$viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper('viewRenderer');
$viewRenderer-&gt;setView($view);

                </pre>
</li>
</ul></div>
<p>
            有许多办法来修改<code class="code">ViewRenderer</code>，包括设置不同的视图脚本来调用，给所有视图脚本路径（包括后缀）可替换元素指定替代，选择响应指定的段来利用，等等。如果你不使用传统模块目录结构，你甚至可以用<code class="code">ViewRenderer</code>联合不同的路径规范。
        </p>
<p>
            我们鼓励你用<code class="code">ErrorHandler</code> 和 <code class="code">ViewRenderer</code>改编你的代码，因为它们现在是核心功能。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.migration.fromzeroninetwo"></a>12.13.4. 从 0.9.2 移植到 0.9.3 或更新的版本</h3></div></div></div>
<p>
            0.9.3 介绍了<a href="zend.controller.actionhelpers.html" title="12.8. 动作助手">action helpers</a>。作为这个改变的一部分，下面的方法已经删除因为它们现在被封装到<a href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.redirector" title="12.8.4.6. 转向器(Redirector)">重定向动作助手</a>：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">setRedirectCode()</code>；使用 <code class="code">Zend_Controller_Action_Helper_Redirector::setCode()</code>。
                </p></li>
<li><p>
                    <code class="code">setRedirectPrependBase()</code>；使用 <code class="code">Zend_Controller_Action_Helper_Redirector::setPrependBase()</code>。
                </p></li>
<li><p>
                    <code class="code">setRedirectExit()</code>；使用 <code class="code">Zend_Controller_Action_Helper_Redirector::setExit()</code>。
                </p></li>
</ul></div>
<p>
            阅读<a href="zend.controller.actionhelpers.html" title="12.8. 动作助手">动作助手文档</a>有更多的信息关于如何获取和操作助手对象，还有<a href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.redirector" title="12.8.4.6. 转向器(Redirector)">重定向助手文档</a>有更多信息关于设置重定向选项（还有重定向的替代方法）。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.migration.fromzerosix"></a>12.13.5. 从 0.6.0 移植到 0.8.0 或更新的版本 </h3></div></div></div>
<p>
            每次修改，MVC组件的最基本用法保持不变：
        </p>
<pre class="programlisting">
Zend_Controller_Front::run('/path/to/controllers');

        </pre>
<p>
            然而，目录结构经历了检查，数个组件被删除，同时若干个其它的被改名或添加。变化包括：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">Zend_Controller_Router</code> 被删除有利于rewrite路由器。
                </p></li>
<li><p>
                    <code class="code">Zend_Controller_RewriteRouter</code> 改名为 <code class="code">Zend_Controller_Router_Rewrite</code>，并提升为标准路由器和框架一起发行；如果没有提供其它路由器 <code class="code">Zend_Controller_Front</code> 将使用它为缺省的路由器。
                </p></li>
<li><p>
                    使用rewrite路由器的新路由被引入，<code class="code">Zend_Controller_Router_Route_Module</code>；它覆盖了MVC使用的缺省路由，并支持<a href="zend.controller.modular.html" title="12.11. 使用传统的模块目录结构">控制器模块 </a>。
                </p></li>
<li><p>
                    <code class="code">Zend_Controller_Router_StaticRoute</code> 改名为 <code class="code">Zend_Controller_Router_Route_Static</code>。
                </p></li>
<li><p>
                    <code class="code">Zend_Controller_Dispatcher</code> 改名为 <code class="code">Zend_Controller_Dispatcher_Standard</code>。
                </p></li>
<li>
<p>
                    <code class="code">Zend_Controller_Action::_forward()</code>的参数被修改。签名现在是：
                </p>
<pre class="programlisting">
final protected function _forward($action, $controller = null, $module = null, array $params = null);

                </pre>
<p>
                    <code class="code">$action</code>总是被要求的；如果没有指定控制器，在当前控制器中的动作被使用。<code class="code">$module</code> 总是被忽略除非 <code class="code">$controller</code> 被指定。最后，任何提供的<code class="code">$params</code> 将被追加到请求对象。如果你不请求控制器或模块，当仍需要传递参数，简单地指定null到这些值。
                </p>
</li>
</ul></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.migration.fromzerotwo"></a>12.13.6. 从 0.2.0 或以前的版本移植到 0.6.0</h3></div></div></div>
<p>
            （这段就让它保持原样吧 Jason Qi）
        </p>
<p>
            The most basic usage of the MVC components has not changed; you can
            still do each of the following:
        </p>
<pre class="programlisting">
Zend_Controller_Front::run('/path/to/controllers');

        </pre>
<pre class="programlisting">
/* -- create a router -- */
$router = new Zend_Controller_RewriteRouter();
$router-&gt;addRoute('user', 'user/:username', array('controller' =&gt; 'user',
'action' =&gt; 'info'));

/* -- set it in a controller -- */
$ctrl = Zend_Controller_Front::getInstance();
$ctrl-&gt;setRouter($router);

/* -- set controller directory and dispatch -- */
$ctrl-&gt;setControllerDirectory('/path/to/controllers');
$ctrl-&gt;dispatch();

        </pre>
<p>
            We encourage use of the Response object to aggregate content and
            headers. This will allow for more flexible output format switching
            (for instance, JSON or XML instead of XHTML) in your applications.
            By default, <code class="code">dispatch()</code> will render the response, sending both
            headers and rendering any content. You may also have the front
            controller return the response using <code class="code">returnResponse()</code>,
            and then render the response using your own logic. A future version
            of the front controller may enforce use of the response object via
            output buffering.
        </p>
<p>
            There are many additional features that extend the existing API,
            and these are noted in the documentation.
        </p>
<p>
            The main changes you will need to be aware of will be found when
            subclassing the various components. Key amongst these are:
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
<p>
                    <code class="code">Zend_Controller_Front::dispatch()</code> by default
                    traps exceptions in the response object, and does not render
                    them, in order to prevent sensitive system information from
                    being rendered. You can override this in several ways:
                </p>
<div class="itemizedlist"><ul type="circle">
<li>
<p>
                            Set <code class="code">throwExceptions()</code> in the front
                            controller:
                        </p>
<pre class="programlisting">
$front-&gt;throwExceptions(true);

                        </pre>
</li>
<li>
<p>
                            Set <code class="code">renderExceptions()</code> in the response
                            object:
                        </p>
<pre class="programlisting">
$response-&gt;renderExceptions(true);
$front-&gt;setResponse($response);
$front-&gt;dispatch();

// or:
$front-&gt;returnResponse(true);
$response = $front-&gt;dispatch();
$response-&gt;renderExceptions(true);
echo $response;

                        </pre>
</li>
</ul></div>
</li>
<li><p>
                <code class="code">Zend_Controller_Dispatcher_Interface::dispatch()</code>
                now accepts and returns a <a href="zend.controller.request.html" title="12.4. 请求对象">第 12.4 节 “请求对象”</a>
                object instead of a dispatcher token.
            </p></li>
<li><p>
                <code class="code">Zend_Controller_Router_Interface::route()</code>
                now accepts and returns a <a href="zend.controller.request.html" title="12.4. 请求对象">第 12.4 节 “请求对象”</a>
                object instead of a dispatcher token.
            </p></li>
<li>
<p><code class="code">Zend_Controller_Action</code> changes include:</p>
<div class="itemizedlist"><ul type="circle">
<li><p>
                        The constructor now accepts exactly three arguments,
                        <code class="code">Zend_Controller_Request_Abstract $request</code>,
                        <code class="code">Zend_Controller_Response_Abstract $response</code>,
                        and <code class="code">array $params (optional)</code>.
                        <code class="code">Zend_Controller_Action::__construct()</code> uses
                        these to set the request, response, and invokeArgs
                        properties of the object, and if overriding the
                        constructor, you should do so as well. Better yet, use
                        the <code class="code">init()</code> method to do any instance
                        configuration, as this method is called as the final
                        action of the constructor.
                    </p></li>
<li><p>
                        <code class="code">run()</code> is no longer defined as final, but is
                        also no longer used by the front controller; it's sole
                        purpose is for using the class as a page controller. It
                        now takes two optional arguments, a
                        <code class="code">Zend_Controller_Request_Abstract $request</code>
                        and a <code class="code">Zend_Controller_Response_Abstract $response</code>.
                    </p></li>
<li><p>
                        <code class="code">indexAction()</code> no longer needs to be
                        defined, but is encouraged as the default action. This
                        allows using the RewriteRouter and action controllers to
                        specify different default action methods.
                    </p></li>
<li><p>
                        <code class="code">__call()</code> should be overridden to handle any
                        undefined actions automatically.
                    </p></li>
<li><p>
                        <code class="code">_redirect()</code> now takes an optional second
                        argument, the HTTP code to return with the redirect, and
                        an optional third argument, <code class="code">$prependBase</code>,
                        that can indicate that the base URL registered with the
                        request object should be prepended to the url specified.
                    </p></li>
<li>
<p>
                            The <code class="code">_action</code> property is no longer set.
                            This property was a <code class="code">Zend_Controller_Dispatcher_Token</code>,
                            which no longer exists in the current incarnation.
                            The sole purpose of the token was to provide
                            information about the requested controller, action,
                            and URL parameters. This information is now
                            available in the request object, and can be accessed
                            as follows:
                        </p>
<pre class="programlisting">
// Retrieve the requested controller name
// Access used to be via: $this-&gt;_action-&gt;getControllerName().
// The example below uses getRequest(), though you may also directly access the
// $_request property; using getRequest() is recommended as a parent class may
// override access to the request object.
$controller = $this-&gt;getRequest()-&gt;getControllerName();

// Retrieve the requested action name
// Access used to be via: $this-&gt;_action-&gt;getActionName().
$action = $this-&gt;getRequest()-&gt;getActionName();

// Retrieve the request parameters
// This hasn't changed; the _getParams() and _getParam() methods simply proxy to
// the request object now.
$params = $this-&gt;_getParams();
$foo = $this-&gt;_getParam('foo', 'default'); // request 'foo' parameter, using
                                           // 'default' as default value if not found

                        </pre>
</li>
<li>
<p>
                            <code class="code">noRouteAction()</code> has been removed. The
                            appropriate way to handle non-existent action
                            methods should you wish to route them to a default
                            action is using <code class="code">__call()</code>:
                        </p>
<pre class="programlisting">
public function __call($method, $args)
{
    // If an unmatched 'Action' method was requested, pass on to the default
    // action method:
    if ('Action' == substr($method, -6)) {
        return $this-&gt;defaultAction();
    }

    throw new Zend_Controller_Exception('Invalid method called');
}

                        </pre>
</li>
</ul></div>
</li>
<li><p>
                <code class="code">Zend_Controller_RewriteRouter::setRewriteBase()</code> has
                been removed. Use <code class="code">Zend_Controller_Front::setBaseUrl()</code>
                instead (or Zend_Controller_Request_Http::setBaseUrl(), if using
                that request class).
            </p></li>
<li><p>
                <code class="code">Zend_Controller_Plugin_Interface</code> was replaced
                by <code class="code">Zend_Controller_Plugin_Abstract</code>. All methods now
                accept and return a <a href="zend.controller.request.html" title="12.4. 请求对象">第 12.4 节 “请求对象”</a>
                object instead of a dispatcher token.
            </p></li>
</ul></div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.controller.exceptions.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.controller.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.currency.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">12.12. MVC 异常 </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 第 13 章 Zend_Currency</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
