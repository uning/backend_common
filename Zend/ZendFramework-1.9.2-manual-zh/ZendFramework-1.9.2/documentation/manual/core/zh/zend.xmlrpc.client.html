<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>63.2. Zend_XmlRpc_Client</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="prev" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="next" href="zend.xmlrpc.server.html" title="63.3. Zend_XmlRpc_Server">
<link rel="chapter" href="introduction.html" title="第 1 章 Zend Framework简介">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.amf.html" title="第 3 章 Zend_Amf">
<link rel="chapter" href="zend.application.html" title="第 4 章 Zend_Application">
<link rel="chapter" href="zend.auth.html" title="第 5 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 6 章 Zend_Cache">
<link rel="chapter" href="zend.captcha.html" title="第 7 章 Zend_Captcha">
<link rel="chapter" href="zend.codegenerator.html" title="第 8 章 Zend_CodeGenerator">
<link rel="chapter" href="zend.config.html" title="第 9 章 Zend_Config">
<link rel="chapter" href="zend.config.writer.html" title="第 10 章 Zend_Config_Writer">
<link rel="chapter" href="zend.console.getopt.html" title="第 11 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="zend.date.html" title="第 14 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 15 章 Zend_Db">
<link rel="chapter" href="zend.debug.html" title="第 16 章 Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="第 17 章 Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="第 18 章 Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="第 19 章 Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="第 20 章 Zend_Feed">
<link rel="chapter" href="zend.file.html" title="第 21 章 Zend_File">
<link rel="chapter" href="zend.filter.html" title="第 22 章 Zend_Filter">
<link rel="chapter" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="第 24 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 25 章 Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="第 26 章 Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="第 27 章 Zend_Json">
<link rel="chapter" href="zend.layout.html" title="第 28 章 Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="第 29 章 Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="第 30 章 Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="第 31 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 32 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 33 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 34 章 Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="第 35 章 Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="第 36 章 Zend_Mime">
<link rel="chapter" href="zend.navigation.html" title="第 37 章 Zend_Navigation">
<link rel="chapter" href="zend.openid.html" title="第 38 章 Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="zend.progressbar.html" title="第 41 章 Zend_ProgressBar">
<link rel="chapter" href="zend.queue.html" title="第 42 章 Zend_Queue">
<link rel="chapter" href="zend.reflection.html" title="第 43 章 Zend_Reflection">
<link rel="chapter" href="zend.registry.html" title="第 44 章 Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="第 45 章 Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="第 46 章 Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="第 47 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 48 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 49 章 Zend_Session">
<link rel="chapter" href="zend.soap.html" title="第 50 章 Zend_Soap">
<link rel="chapter" href="zend.tag.html" title="第 51 章 Zend_Tag">
<link rel="chapter" href="zend.test.html" title="第 52 章 Zend_Test">
<link rel="chapter" href="zend.text.html" title="第 53 章 Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="第 54 章 Zend_TimeSync">
<link rel="chapter" href="zend.tool.framework.html" title="第 55 章 Zend_Tool_Framework">
<link rel="chapter" href="zend.tool.project.html" title="第 56 章 Zend_Tool_Project">
<link rel="chapter" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="第 58 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 59 章 Zend_Validate">
<link rel="chapter" href="zend.version.html" title="第 60 章 Zend_Version">
<link rel="chapter" href="zend.view.html" title="第 61 章 Zend_View">
<link rel="chapter" href="zend.wildfire.html" title="第 62 章 Zend_Wildfire">
<link rel="chapter" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="chapter" href="zendx.console.process.unix.html" title="第 64 章 ZendX_Console_Process_Unix">
<link rel="chapter" href="zendx.jquery.html" title="第 65 章 ZendX_JQuery">
<link rel="appendix" href="requirements.html" title="附录 A. 系统需求">
<link rel="appendix" href="coding-standard.html" title="附录 B. Zend Framework 的 PHP 编码标准">
<link rel="appendix" href="doc-standard.html" title="附录 C. Zend Framework Documentation Standard">
<link rel="appendix" href="project-structure.html" title="附录 D. Recommended Project Structure for Zend Framework MVC Applications">
<link rel="appendix" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="appendix" href="copyrights.html" title="附录 F. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.client.introduction" title="63.2.1. 介绍">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.client.method-calls" title="63.2.2. 方法调用">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.value.parameters" title="63.2.3. 类型及转换">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.client.requests-and-responses" title="63.2.4. 服务代理对象">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.client.error-handling" title="63.2.5. 错误处理">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.client.introspection" title="63.2.6. 服务器自省（introspection）">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.client.request-to-response" title="63.2.7. 从请求作出回应">
<link rel="subsection" href="zend.xmlrpc.client.html#zend.xmlrpc.client.http-client" title="63.2.8. HTTP 客户端和测试">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">63.2. Zend_XmlRpc_Client</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.xmlrpc.html">上一页</a> </td>
<th width="60%" align="center">第 63 章 Zend_XmlRpc</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.xmlrpc.server.html">下一页</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.xmlrpc.client"></a>63.2. Zend_XmlRpc_Client</h2></div></div></div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.introduction"></a>63.2.1. 介绍</h3></div></div></div>
<p>
            Zend Framework 通过 <code class="code">Zend_XmlRpc_Client</code> 作为客户端提供了调用远程
            XML-RPC 服务的功能。主要功能包括在 PHP 和 XML-RPC 之间进行类型的自动转换，
            服务代理对象（a server proxy object），和访问服务器的自省功能
            （introspection capabilities）。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.method-calls"></a>63.2.2. 方法调用</h3></div></div></div>
<p>
            <code class="code">Zend_XmlRpc_Client</code> 的构造函数接受 XML-RPC 服务器端 URL
            地址作为第一个参数。返回新的实例可以用来调用这个服务器端任意数量的远程方法。
        </p>
<p>
            使用 XML-RPC 客户端调用远程方法，需要实例化它并且使用 <code class="code">call()</code>
            实力方法。下面的代码演示了调用 Zend Framework 网站上的 XML-RPC 服务。
            你可以使用它测试和学习 <code class="code">Zend_XmlRpc</code> 组件。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.method-calls.example-1"></a><p class="title"><b>例 63.1. XML-RPC 方法调用</b></p>
<div class="example-contents"><pre class="programlisting">
require_once 'Zend/XmlRpc/Client.php';

$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

echo $client-&gt;call('test.sayHello');

// hello

            </pre></div>
</div>
<br class="example-break"><p>
            从远程调用返回的 XML-RPC 值将会自动编排和转换为等价的 PHP 原始类型。
            在上面的例子中，一个 PHP <code class="code">string</code> 会返回并即刻可以使用。
        </p>
<p>
            <code class="code">call()</code> 方法接受远程调用的名字作为第一个参数。如果远程调用需要其他参数，
            可以通过 <code class="code">call()</code> 的第二个可选参数使用 <code class="code">array</code>
            的形式传递到远程方法。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.method-calls.example-2"></a><p class="title"><b>例 63.2. XML-RPC 带参数的方法调用</b></p>
<div class="example-contents"><pre class="programlisting">
require_once 'Zend/XmlRpc/Client.php';

$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$arg1 = 1.1;
$arg2 = 'foo';

$result = $client-&gt;call('test.sayHello', array($arg1, $arg2));

// $result is a native PHP type

            </pre></div>
</div>
<br class="example-break"><p>
            如果远程方法不需要任何参数，这个可选参数可以留空或者传递一个空的 <code class="code">array()</code>
            过去。远程方法的参数数组可以包含原始的 PHP 类型，<code class="code">Zend_XmlRpc_Value</code>
            对象，或者两种的混合。
        </p>
<p>
            <code class="code">call()</code> 方法会自动转换 XML-PRC 响应并返回等价的 PHP 原始类型。
            返回值的 <code class="code">Zend_XmlRpc_Response</code> 对象也可以在调用之后使用
            <code class="code">getLastResponse()</code> 方法获得。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.value.parameters"></a>63.2.3. 类型及转换</h3></div></div></div>
<p>
            一些远程方法调用时需要参数。它们作为数组传递到 <code class="code">Zend_XmlRpc_Client</code>
            的 <code class="code">call()</code> 方法的第二个参数。每个参数，不论是原始的 PHP 类型，
            还是一个对象表示的特定的 XML-RPC 类型（一个 <code class="code">Zend_XmlRpc_Value</code>
            对象）都会自动转换。
        </p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.value.parameters.php-native"></a>63.2.3.1. PHP 原始类型作为参数</h4></div></div></div>
<p>
                原始 PHP 变量如 <code class="code">string</code>，<code class="code">integer</code>，
                <code class="code">float</code>，<code class="code">boolean</code>，<code class="code">array</code> 或者
                <code class="code">object</code> 都可以作为参数传递到 <code class="code">call()</code>。
                在这种情况下，每个 PHP 原始类型将会自动检测和转换到一个 XML-RPC 类型，
                如下表所示：
            </p>
<div class="table">
<a name="zend.xmlrpc.value.parameters.php-native.table-1"></a><p class="title"><b>表 63.1. PHP 与 XML-RPC 的类型转换</b></p>
<div class="table-contents"><table summary="PHP 与 XML-RPC 的类型转换" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>PHP 原始类型</th>
<th>XML-RPC 类型</th>
</tr></thead>
<tbody>
<tr>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
<tr>
<td>boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>array</td>
<td>array</td>
</tr>
<tr>
<td>associative array</td>
<td>struct</td>
</tr>
<tr>
<td>object</td>
<td>array</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="note"><table border="0" summary="Note: 一个空的数组会如何转换？">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">一个空的数组会如何转换？</th>
</tr>
<tr><td align="left" valign="top">
<p>
                    传递空数组到 XML-RPC 方法，由于它既可表示为一个数组也可表示为一个结构，
                    所以会产生问题。<code class="code">Zend_XmlRpc_Client</code> 会监测这种情况并向服务器进行一个
                    <code class="code">system.methodSignature</code> 请求来决定实际将要转换到的 XML-RPC 类型。
                </p>
<p>
                    不过，这样做本身就可能导致问题出现。首先，服务器不支持 <code class="code">system.methodSignature</code>
                    将会产生一个失败请求，同时 <code class="code">Zend_XmlRpc_Client</code>
                    会强制转换这个值为 XML-RPC 数组类型。此外，这意味着任何数组参数都可能导致对远端服务器的一次额外请求。
                </p>
<p>
                    可以在 XML-RPC 调用前调用 <code class="code">setSkipSystemLookup()</code>
                    方法，以便完全屏蔽这个查询：
                </p>
<pre class="programlisting">
$client-&gt;setSkipSystemLookup(true);
$result = $client-&gt;call('foo.bar', array(array()));

                </pre>
</td></tr>
</table></div>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.value.parameters.xmlrpc-value"></a>63.2.3.2. <code class="code">Zend_XmlRpc_Value</code> 对象作为参数</h4></div></div></div>
<p>
                也可以创建 <code class="code">Zend_XmlRpc_Value</code> 实例作为参数，以表示特定的
                XML-RPC 类型。这样做的主要原因如下：
                </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                            当希望确定的参数类型被传递传递时（例如，方法需要一个整型，
                            而可能从数据库获得的是一个字符串）。
                        </p></li>
<li><p>
                            当方法需要 <code class="code">base64</code> 或者 <code class="code">dateTime.iso8601</code>
                            类型时（这些在 PHP 原始类型中不存在）。
                        </p></li>
<li><p>
                            当自动转换失败时（例如，你希望传递一个空的 XML-RPC
                            结构作为参数。空的结构在 PHP 中应当是一个空的数组，
                            但是如果传递一个空数组作为参数，它将被自动转换为 XML-RPC
                            数组，虽然它同数组没有联系）。
                        </p></li>
</ul></div>
<p>
            </p>
<p>
                有两种方法创建 <code class="code">Zend_XmlRpc_Value</code> 对象：直接实例化某个
                <code class="code">Zend_XmlRpc_Value</code> 的子类；或者使用静态工厂方法
                <code class="code">Zend_XmlRpc_Value::getXmlRpcValue()</code>。
            </p>
<div class="table">
<a name="zend.xmlrpc.value.parameters.xmlrpc-value.table-1"></a><p class="title"><b>表 63.2. <code class="code">Zend_XmlRpc_Value</code> 对象作为 XML-RPC 类型</b></p>
<div class="table-contents"><table summary="Zend_XmlRpc_Value 对象作为 XML-RPC 类型" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>XML-RPC 类型</th>
<th>
<code class="code">Zend_XmlRpc_Value</code> 常量</th>
<th>
<code class="code">Zend_XmlRpc_Value</code> 对象</th>
</tr></thead>
<tbody>
<tr>
<td>int</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_INTEGER</code></td>
<td><code class="code">Zend_XmlRpc_Value_Integer</code></td>
</tr>
<tr>
<td>double</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_DOUBLE</code></td>
<td><code class="code">Zend_XmlRpc_Value_Double</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_BOOLEAN</code></td>
<td><code class="code">Zend_XmlRpc_Value_Boolean</code></td>
</tr>
<tr>
<td>string</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_STRING</code></td>
<td><code class="code">Zend_XmlRpc_Value_String</code></td>
</tr>
<tr>
<td>base64</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_BASE64</code></td>
<td><code class="code">Zend_XmlRpc_Value_Base64</code></td>
</tr>
<tr>
<td>dateTime.iso8601</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_DATETIME</code></td>
<td><code class="code">Zend_XmlRpc_Value_DateTime</code></td>
</tr>
<tr>
<td>array</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_ARRAY</code></td>
<td><code class="code">Zend_XmlRpc_Value_Array</code></td>
</tr>
<tr>
<td>struct</td>
<td><code class="code">Zend_XmlRpc_Value::XMLRPC_TYPE_STRUCT</code></td>
<td><code class="code">Zend_XmlRpc_Value_Struct</code></td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
                </p>
<div class="note"><table border="0" summary="Note: 自动转换">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">自动转换</th>
</tr>
<tr><td align="left" valign="top"><p>
                        当创建新的 <code class="code">Zend_XmlRpc_Value</code> 对象时，它的值通过
                        PHP 类型设置。PHP 类型将会通过 PHP 类型转换到指定的类型。例如，
                        如果给 <code class="code">Zend_XmlRpc_Value_Integer</code>
                        对象提供一个字符串，它将由 <code class="code">(int)$value</code> 转换。
                    </p></td></tr>
</table></div>
<p>
            </p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.requests-and-responses"></a>63.2.4. 服务代理对象</h3></div></div></div>
<p>
            另一个使用 XML-RPC 客户端调用远程方法的途径是使用服务代理。这是一个 PHP
            对象代理远程 XML-RPC 名字空间，使其工作方式尽可能的贴近原始的 PHP 对象。
        </p>
<p>
            调用 <code class="code">Zend_XmlRpc_Client</code> 实例的 <code class="code">getProxy()</code>
            方法实例化一个服务器代理。该方法将返回一个 <code class="code">Zend_XmlRpc_Client_ServerProxy</code>
            实例。对服务器代理方法的任何调用将会传递到远程，而参数的传递就如同其他任何
            PHP 方法一样。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.requests-and-responses.example-1"></a><p class="title"><b>例 63.3. 代理默认命名空间</b></p>
<div class="example-contents"><pre class="programlisting">
require_once 'Zend/XmlRpc/Client.php';

$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$server = $client-&gt;getProxy();           // Proxy the default namespace

$hello = $server-&gt;test-&gt;sayHello(1, 2);  // test.Hello(1, 2) returns "hello"

            </pre></div>
</div>
<br class="example-break"><p>
            <code class="code">getProxy()</code> 方法接受一个可选参数作为将要代理的远端服务器的命名空间。
            如果没有指定这个命名空间，默认的命名空间会被代理。在下面的例子中，命名空间
            <code class="code">test</code> 将会被代理。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.requests-and-responses.example-2"></a><p class="title"><b>例 63.4. 代理任意命名空间</b></p>
<div class="example-contents"><pre class="programlisting">
$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$test  = $client-&gt;getProxy('test');     // Proxy the "test" namespace

$hello = $test-&gt;sayHello(1, 2);         // test.Hello(1,2) returns "hello"

            </pre></div>
</div>
<br class="example-break"><p>
            若远端服务器支持任意深度嵌套的命名空间，仍然可以通过服务器代理使用。例如，
            如果上面的例子有一个方法 <code class="code">test.foo.bar()</code>，则可以使用
            <code class="code">$test-&gt;foo-&gt;bar()</code> 来调用。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.error-handling"></a>63.2.5. 错误处理</h3></div></div></div>
<p>
            在 XML-RPC 方法中可能出现两种错误：HTTP 错误和 XML-RPC 失败。
            <code class="code">Zend_XmlRpc_Client</code> 可以识别并分别检测并捕获它们。
        </p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.client.error-handling.http"></a>63.2.5.1. HTTP 错误</h4></div></div></div>
<p>
                当 HTTP 错误发生时，例如远端 HTTP 服务器返回
                <code class="code">404 Not Found</code>，将会抛出一个
                <code class="code">Zend_XmlRpc_Client_HttpException</code> 异常。
            </p>
<div class="example">
<a name="zend.xmlrpc.client.error-handling.http.example-1"></a><p class="title"><b>例 63.5. 处理 HTTP 错误</b></p>
<div class="example-contents"><pre class="programlisting">
$client = new Zend_XmlRpc_Client('http://foo/404');

try {

    $client-&gt;call('bar', array($arg1, $arg2));

} catch (Zend_XmlRpc_Client_HttpException $e) {

    // $e-&gt;getCode() returns 404
    // $e-&gt;getMessage() returns "Not Found"

}

                </pre></div>
</div>
<br class="example-break"><p>
                不论是如何使用 XML-RPC 客户端的，当 HTTP 错误发生时，都会抛出
                <code class="code">Zend_XmlRpc_Client_HttpException</code> 异常。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.client.error-handling.faults"></a>63.2.5.2. XML-RPC 失败</h4></div></div></div>
<p>
                XML-RPC 失败类似于 PHP 异常。它是从 XML-RPC 方法调用返回的，有着指定的类型，
                同时具有错误代码和错误消息。XML-RPC 失败的处理方式随着 <code class="code">Zend_XmlRpc_Client</code>
                使用方式不同而不同。
            </p>
<p>
                当 <code class="code">call()</code> 方法或者服务器代理对象被使用时，XML-RPC
                失败会抛出一个 <code class="code">Zend_XmlRpc_Client_FaultException</code>
                异常。异常代码和消息会直接映射到原始的 XML-RPC 失败相应的内容上去。
            </p>
<div class="example">
<a name="zend.xmlrpc.client.error-handling.faults.example-1"></a><p class="title"><b>例 63.6. 处理 XML-RPC 失败</b></p>
<div class="example-contents"><pre class="programlisting">
$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

try {

    $client-&gt;call('badMethod');

} catch (Zend_XmlRpc_Client_FaultException $e) {

    // $e-&gt;getCode() returns 1
    // $e-&gt;getMessage() returns "Unknown method"

}

                </pre></div>
</div>
<br class="example-break"><p>
                当请求时使用 <code class="code">call()</code> 方法，会在失败的时候抛出
                <code class="code">Zend_XmlRpc_Client_FaultException</code> 异常。可以调用
                <code class="code">getLastResponse()</code> 获得包含在 <code class="code">Zend_XmlRpc_Response</code>
                对象中的异常。
            </p>
<p>
                当请求时使用 <code class="code">doRequest()</code> 方法，则不会抛出异常。将返回一个包含错误信息的
                <code class="code">Zend_XmlRpc_Response</code> 对象。可以使用 <code class="code">Zend_XmlRpc_Response</code>
                示例的 <code class="code">isFault()</code> 方法检查。
            </p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.introspection"></a>63.2.6. 服务器自省（introspection）</h3></div></div></div>
<p>
            一些 XML-RPC 服务器支持 <code class="code">system.</code> 命名空间下的自省。<code class="code">Zend_XmlRpc_Client</code>
            对这些服务器的这种功能特别进行了支持。
        </p>
<p>
            调用 <code class="code">Zend_XmlRpcClient</code> 的 <code class="code">getIntrospector()</code>
            方法可以获得 <code class="code">Zend_XmlRpc_Client_ServerIntrospection</code> 实例。
            通过它可以使用服务器的自省功能。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.request-to-response"></a>63.2.7. 从请求作出回应</h3></div></div></div>
<p>
            本质上说，<code class="code">Zend_XmlRpc_Client</code> 实例的 <code class="code">call()</code>
            方法创建了请求对象（<code class="code">Zend_XmlRpc_Request</code>）并将其传递给另一个方法
            <code class="code">doRequest()</code>，<code class="code">doRequest()</code> 方法返回响应对象（<code class="code">Zend_XmlRpc_Response</code>）。
        </p>
<p>
            <code class="code">doRequest()</code> 方法也可直接调用。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.request-to-response.example-1"></a><p class="title"><b>例 63.7. 处理请求作出回应</b></p>
<div class="example-contents"><pre class="programlisting">
$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$request = new Zend_XmlRpc_Request();
$request-&gt;setMethod('test.sayHello');
$request-&gt;setParams(array('foo', 'bar'));

$client-&gt;doRequest($request);

// $server-&gt;getLastRequest() returns instanceof Zend_XmlRpc_Request
// $server-&gt;getLastResponse() returns instanceof Zend_XmlRpc_Response

            </pre></div>
</div>
<br class="example-break"><p>
            无论客户端通过任何方法调用 XML-RPC 方法，如 <code class="code">call()</code> 方法、
            <code class="code">doRequest()</code> 方法或者服务器代理，最后一个请求对象以及对应的响应对象总是可以分别调用
            <code class="code">getLastRequest()</code> 和 <code class="code">getLastResponse()</code> 获得。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.http-client"></a>63.2.8. HTTP 客户端和测试</h3></div></div></div>
<p>
            在前面所有的例子中，从未指定 HTTP 客户端。这是因为在使用 <code class="code">Zend_XmlRpc_Client</code>
            时会使用默认配置自动创建一个 <code class="code">Zend_Http_Client</code> 实例。
        </p>
<p>
            可以在任何时候使用 <code class="code">getHttpClient()</code> 方法获得 HTTP 客户端。
            多数情况下默认的 HTTP 客户端已经足够使用。不过仍然可以使用 <code class="code">setHttpClient()</code>
            方法设置新的 HTTP 客户端实例。
        </p>
<p>
            <code class="code">setHttpClient()</code> 在单元测试时特别有用。在 <code class="code">Zend_Http_Client_Adapter_Test</code>
            中测试时可以欺骗远程服务器。阅读 <code class="code">Zend_XmlRpc_Client</code> 的单元测试了解如何这样做。
        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.xmlrpc.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.xmlrpc.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.xmlrpc.server.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">第 63 章 Zend_XmlRpc </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 63.3. Zend_XmlRpc_Server</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
