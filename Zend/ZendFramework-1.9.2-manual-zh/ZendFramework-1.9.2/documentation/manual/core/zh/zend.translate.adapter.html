<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>57.2. Zend_Translate适配器</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="prev" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="next" href="zend.translate.using.html" title="57.3. Using Translation Adapters">
<link rel="chapter" href="introduction.html" title="第 1 章 Zend Framework简介">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.amf.html" title="第 3 章 Zend_Amf">
<link rel="chapter" href="zend.application.html" title="第 4 章 Zend_Application">
<link rel="chapter" href="zend.auth.html" title="第 5 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 6 章 Zend_Cache">
<link rel="chapter" href="zend.captcha.html" title="第 7 章 Zend_Captcha">
<link rel="chapter" href="zend.codegenerator.html" title="第 8 章 Zend_CodeGenerator">
<link rel="chapter" href="zend.config.html" title="第 9 章 Zend_Config">
<link rel="chapter" href="zend.config.writer.html" title="第 10 章 Zend_Config_Writer">
<link rel="chapter" href="zend.console.getopt.html" title="第 11 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="zend.date.html" title="第 14 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 15 章 Zend_Db">
<link rel="chapter" href="zend.debug.html" title="第 16 章 Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="第 17 章 Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="第 18 章 Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="第 19 章 Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="第 20 章 Zend_Feed">
<link rel="chapter" href="zend.file.html" title="第 21 章 Zend_File">
<link rel="chapter" href="zend.filter.html" title="第 22 章 Zend_Filter">
<link rel="chapter" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="第 24 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 25 章 Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="第 26 章 Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="第 27 章 Zend_Json">
<link rel="chapter" href="zend.layout.html" title="第 28 章 Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="第 29 章 Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="第 30 章 Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="第 31 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 32 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 33 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 34 章 Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="第 35 章 Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="第 36 章 Zend_Mime">
<link rel="chapter" href="zend.navigation.html" title="第 37 章 Zend_Navigation">
<link rel="chapter" href="zend.openid.html" title="第 38 章 Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="zend.progressbar.html" title="第 41 章 Zend_ProgressBar">
<link rel="chapter" href="zend.queue.html" title="第 42 章 Zend_Queue">
<link rel="chapter" href="zend.reflection.html" title="第 43 章 Zend_Reflection">
<link rel="chapter" href="zend.registry.html" title="第 44 章 Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="第 45 章 Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="第 46 章 Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="第 47 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 48 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 49 章 Zend_Session">
<link rel="chapter" href="zend.soap.html" title="第 50 章 Zend_Soap">
<link rel="chapter" href="zend.tag.html" title="第 51 章 Zend_Tag">
<link rel="chapter" href="zend.test.html" title="第 52 章 Zend_Test">
<link rel="chapter" href="zend.text.html" title="第 53 章 Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="第 54 章 Zend_TimeSync">
<link rel="chapter" href="zend.tool.framework.html" title="第 55 章 Zend_Tool_Framework">
<link rel="chapter" href="zend.tool.project.html" title="第 56 章 Zend_Tool_Project">
<link rel="chapter" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="第 58 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 59 章 Zend_Validate">
<link rel="chapter" href="zend.version.html" title="第 60 章 Zend_Version">
<link rel="chapter" href="zend.view.html" title="第 61 章 Zend_View">
<link rel="chapter" href="zend.wildfire.html" title="第 62 章 Zend_Wildfire">
<link rel="chapter" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="chapter" href="zendx.console.process.unix.html" title="第 64 章 ZendX_Console_Process_Unix">
<link rel="chapter" href="zendx.jquery.html" title="第 65 章 ZendX_JQuery">
<link rel="appendix" href="requirements.html" title="附录 A. 系统需求">
<link rel="appendix" href="coding-standard.html" title="附录 B. Zend Framework 的 PHP 编码标准">
<link rel="appendix" href="doc-standard.html" title="附录 C. Zend Framework Documentation Standard">
<link rel="appendix" href="project-structure.html" title="附录 D. Recommended Project Structure for Zend Framework MVC Applications">
<link rel="appendix" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="appendix" href="copyrights.html" title="附录 F. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="subsection" href="zend.translate.adapter.html#zend.translate.adapter.decision" title="57.2.1. 如何判断使用哪种翻译适配器">
<link rel="subsection" href="zend.translate.adapter.html#zend.translate.adapter.selfwritten" title="57.2.2.  集成编写自己的适配器">
<link rel="subsection" href="zend.translate.adapter.html#zend.translate.adapter.caching" title="57.2.3.  加速所有的适配器">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">57.2. Zend_Translate适配器</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.translate.html">上一页</a> </td>
<th width="60%" align="center">第 57 章 Zend_Translate</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.translate.using.html">下一页</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.translate.adapter"></a>57.2. Zend_Translate适配器</h2></div></div></div>
<p>
        Zend_Translate能够处理不同的翻译适配器，每种适配器有它自己的优点和缺点，下面是一个完整的适配器支持列表。
    </p>
<div class="table">
<a name="zend.translate.adapter.table"></a><p class="title"><b>表 57.1. Zend_Translate适配器</b></p>
<div class="table-contents"><table summary="Zend_Translate适配器" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>适配器</th>
<th>描述</th>
<th>Usage</th>
</tr></thead>
<tbody>
<tr>
<td>Array</td>
<td>使用PHP数组</td>
<td>小页面;使用最简单;仅对程序员</td>
</tr>
<tr>
<td>Csv</td>
<td>使用逗号分隔值(*.csv/*.txt)文件</td>
<td>简单的文本文件格式;非常快; 可能有unicode字符的问题</td>
</tr>
<tr>
<td>Gettext</td>
<td>使用二进制gettext (*.mo)文件</td>
<td>Linux GNU标准;非常快;线程安全;需要工具进行转换</td>
</tr>
<tr>
<td>Ini</td>
<td>使用简单的 ini (*.ini) 文件</td>
<td>简单文本文件格式；非常块；可能有 unicode 字符问题</td>
</tr>
<tr>
<td>Tbx</td>
<td>使用基于术语交换 (*.tbx/*.xml) 文件</td>
<td>程序间术语字符串工业标准；XML 格式 </td>
</tr>
<tr>
<td>Tmx</td>
<td>使用 tmx (*.tmx/*.xml) 文件</td>
<td>程序间转化工业标准;XML格式;人可读</td>
</tr>
<tr>
<td>Qt</td>
<td>Use qt linguist (*.ts) files</td>
<td>跨平台程序框架；XML 格式；人可读</td>
</tr>
<tr>
<td>Xliff</td>
<td>使用 xliff (*.xliff/*.xml) 文件</td>
<td>一个比TMX更加简单的格式;XML格式;人可读</td>
</tr>
<tr>
<td>XmlTm</td>
<td>使用 xmltm (*.xml) 文件</td>
<td>XML 文档转换内存工业标准；XML 格式；人可读</td>
</tr>
<tr>
<td>其他</td>
<td>*.sql</td>
<td>与其他适配器不同,可能在将来实现</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.adapter.decision"></a>57.2.1. 如何判断使用哪种翻译适配器</h3></div></div></div>
<p>
            你应该决定对Zend_Translate使用哪种适配器，常常，外部条件,例如一个项目需求或者客户需求为你决定了使用哪种适配器，但是入你站在决策的位置,下面的提示可能有对你的决定帮助。
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>
                决定适配器的时候，应当知道编码的使用。即便 Zend Framework 声明 UTF-8 为缺省编码，你有时候也需要其它编码。
                <code class="code">Zend_Translate</code> 不改变任何定义在源文件种的编码，意味着如果你的 Gettext 源建立在 ISO-8859-1  之上，它也俺此编码返回字符串而不需要转换。
                只有一个唯一的限制：
            </p>
<p>
                当使用基于 xml 源格式如 TMX 或 XLIFF，你必需在 xml 文件头内定义编码，因为不定义编码，xml 文件将被 xml 解析器缺省地当作 UTF-8。
                你也应当知道实际上 xml 文件的编码局限于 PHP 支持的编码是 UTF-8，ISO-8859-1 和 US-ASCII。
            </p>
</td></tr>
</table></div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.array"></a>57.2.1.1. Zend_Translate_Adapter_Array</h4></div></div></div>
<p>
                数组适配器对程序员来说是使用最简单的一种适配器，但是如果你有大量的字符串和许多语言要翻译，你应该考虑其他的适配器。例如，如果你有5000个字符串要翻译，数组适配器对你来说并非最好的选择。
            </p>
<p>
                你应该仅在小规模站点，不多的语言需要翻译时使用本适配器，要是你或则你的开发者团队创建你们自己的翻译。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.csv"></a>57.2.1.2. Zend_Translate_Adapter_Csv</h4></div></div></div>
<p>
                Csv对于用户是使用上最简单的一种适配器，CSV 文件可以通过标准的文本编辑器读取,但是有些文本编辑器通常不支持utf8字符集。
            </p>
<p>
                你应该仅在你的客户需要自己翻译时使用本适配器。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.gettext"></a>57.2.1.3. Zend_Translate_Adapter_Gettext</h4></div></div></div>
<p>
                Gettext适配器是最常用的一种适配器。Gettext是一种由GNU引入的翻译源格式，现在在世界上广泛使用，它不是人可读的，但有几个免费的工具（例如 <a href="http://sourceforge.net/projects/poedit/" target="_top">POEdit</a>），用于读取Gettext数据。Zend_Translate Gettext 适配器并不是使用 PHP 的 gettext 扩展实现的。 你可以在没有安装 PHP 的 gettext 扩展的情况下也能够使用 Gettext 适配器。还有 Zend_Translate 的 Gettext 适配器是线程安全的，而 PHP 的 gettext 扩展当前是非线程安全的。
            </p>
<p>
                大多数人使用本适配器，可用的工具，专业的翻译非常简单。但是 gettext 数据存储为机器可读的格式，没有工具，它是不可读的。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.ini"></a>57.2.1.4. Zend_Translate_Adapter_Ini</h4></div></div></div>
<p>
                Ini 适配器非常简单，客户都可以直接使用。INI 文件可以用标准文本编辑器读出，但文本编辑器一般不支持 utf8 字符集。
            </p>
<p>
                在客户想自己翻译的情况下你只能用这个适配器，对于一般的翻译源，不要使用它。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.tbx"></a>57.2.1.5. Zend_Translate_Adapter_Tbx</h4></div></div></div>
<p>
                Tbx 适配器是给已经为他们的内部翻译系统使用 TBX 格式的客户来使用的。 Tbx 没有标准翻译格式，只是已经翻译的集合和预翻译原文。 当使用这个适配器，你必须确认所需的原文已经翻译。TBX 是基于 XML 文件的格式的全新格式。XML 文件是人类可读的，但是解析的速度却不如 gettext 文件快。
              </p>
<p>
                这个适配器对预翻译原文已存在的公司来说很理想，文件是人类可读，并且不依赖操作系统的。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.tmx"></a>57.2.1.6. Zend_Translate_Adapter_Tmx</h4></div></div></div>
<p>
                Tmx适配器用于有多个系统,并且那些系统使用同样的源格式的大多数客户,或则翻译源格式必须是不依赖与系统的，TMX 是一种基于 XML 的文件格式,它宣称将成为下一个工业标准， XML 文件是人可读的,但是解析的速度却不如 gettext 文件快。
            </p>
<p>
               大多数中到大型的公司使用本适配器，因为文件是人可读的,不依赖于系统。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.qt"></a>57.2.1.7. Zend_Translate_Adapter_Qt</h4></div></div></div>
<p>
                Qt 适配器适用于使用 QtLinguist 生成的 TS 文件作为其翻译源的用户。QT 使用 XML 作为基本文件格式。XML 是用户可读的，但是分析速度比不上 gettext 文件。
            </p>
<p>
                许多应用是构建在 QT 框架之上的。 这个格式的文件是人类可读，并且不依赖操作系统。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.xliff"></a>57.2.1.8. Zend_Translate_Adapter_Xliff</h4></div></div></div>
<p>
                Xliff适配器被那些想使用XML文件但是没有TMX工具的多数客户使用， XLIFF 也是一种基于XML的文件格式,它是于TMX相关的但是比TMX更简单，他仅支持TMX的部分功能。XML文件是人可读的，但是解析的速度却不如gettext文件快 。
            </p>
<p>
                多数中型公司使用此适配器,这个格式的文件是人可读,并且不依赖操作系统。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.translate.adapter.xmltm"></a>57.2.1.9. Zend_Translate_Adapter_XmlTm</h4></div></div></div>
<p>
                XmlTm 适配器为那些做他们自己的布局的客户使用，XmlTm 是允许完全的 html 源包括在翻译源中的文件格式，所以翻译和布局结合在一起。XLIFF 是基于 XML 的文件格式， 和 XLIFF 相关但不容易读。
            </p>
<p>
                这个适配器仅用于源文件已经存在，这个格式的文件是人类可读，并且不依赖操作系统。
            </p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.adapter.selfwritten"></a>57.2.2.  集成编写自己的适配器 </h3></div></div></div>
<p>
            Zend_Translate 允许编写并使用自己的适配器类。并且可以像 Zend_Translate 内置的标准类一样使用。
        </p>
<p>
            任何要在 Zend_Translate 使用的适配器都必须继承于 Zend_Translate_Adapter，抽象类 Zend_Translate_Adapter 定义了所有翻译需要的内容。用户需要做的，就是定义如何读取翻译数据（Translation Data）。
        </p>
<p>
            前缀“Zend”仅限由 Zend_Framework 使用。如果使用自己的适配器扩展了 Zend_Framework，应当命名为 “Company_Translate_Adapter_MyFormat”。下面的代码演示了如何编写一个自定义适配器：
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Translate.php';

try {
    $translate = new Zend_Translate('Company_Translate_Adapter_MyFormat', '/path/to/translate.xx', 'en', array('myoption' =&gt; 'myvalue'));
} catch (Exception $e) {
    // 文件没找到，没有适配器类
    // 通常的错误
}
        </pre>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.translate.adapter.caching"></a>57.2.3.  加速所有的适配器 </h3></div></div></div>
<p>
            <code class="code">Zend_Translate</code>  允许内部使用 <code class="code">Zend_Cache</code>  来加速翻译源文件的加载，如果使用很多翻译源文件或很多源文件格式如基于 XML 的文件格式，这非常好使。
        </p>
<p>
            为使用缓存，将只需要给 <code class="code">Zend_Translate::setCache()</code>  方法一个缓存对象， 它把 <code class="code">Zend_Cache</code> 的实例做为唯一的参数，并且，如果直接使用任何适配器，你可以使用 <code class="code">setCache()</code> 方法。
            静态方法 <code class="code">Zend_Translate::getCache()</code> 可以方便你的使用
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Translate.php';

$cache = Zend_Cache::factory('Page', 'File', $frontendOptions, $backendOptions);
Zend_Translate::setCache($cache);
$translate = new Zend_Translate('gettext', '/path/to/translate.mo', 'en');
        </pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                你必须 <span class="strong"><strong> 在 </strong></span> 使用或初始化任何适配器或 <code class="code">Zend_Translate</code> 的实例 <span class="strong"><strong> 之前 </strong></span> 设置缓存，否则，直到用 <code class="code">addTranslation()</code> 方法添加源文件，翻译源文件将不会缓存。
            </p></td></tr>
</table></div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.translate.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.translate.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.translate.using.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">第 57 章 Zend_Translate </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 57.3. Using Translation Adapters</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
