<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>12.4. 请求对象</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="prev" href="zend.controller.front.html" title="12.3. 前端控制器">
<link rel="next" href="zend.controller.router.html" title="12.5. 标准路由器">
<link rel="chapter" href="introduction.html" title="第 1 章 Zend Framework简介">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.amf.html" title="第 3 章 Zend_Amf">
<link rel="chapter" href="zend.application.html" title="第 4 章 Zend_Application">
<link rel="chapter" href="zend.auth.html" title="第 5 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 6 章 Zend_Cache">
<link rel="chapter" href="zend.captcha.html" title="第 7 章 Zend_Captcha">
<link rel="chapter" href="zend.codegenerator.html" title="第 8 章 Zend_CodeGenerator">
<link rel="chapter" href="zend.config.html" title="第 9 章 Zend_Config">
<link rel="chapter" href="zend.config.writer.html" title="第 10 章 Zend_Config_Writer">
<link rel="chapter" href="zend.console.getopt.html" title="第 11 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="zend.date.html" title="第 14 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 15 章 Zend_Db">
<link rel="chapter" href="zend.debug.html" title="第 16 章 Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="第 17 章 Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="第 18 章 Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="第 19 章 Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="第 20 章 Zend_Feed">
<link rel="chapter" href="zend.file.html" title="第 21 章 Zend_File">
<link rel="chapter" href="zend.filter.html" title="第 22 章 Zend_Filter">
<link rel="chapter" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="第 24 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 25 章 Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="第 26 章 Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="第 27 章 Zend_Json">
<link rel="chapter" href="zend.layout.html" title="第 28 章 Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="第 29 章 Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="第 30 章 Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="第 31 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 32 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 33 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 34 章 Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="第 35 章 Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="第 36 章 Zend_Mime">
<link rel="chapter" href="zend.navigation.html" title="第 37 章 Zend_Navigation">
<link rel="chapter" href="zend.openid.html" title="第 38 章 Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="zend.progressbar.html" title="第 41 章 Zend_ProgressBar">
<link rel="chapter" href="zend.queue.html" title="第 42 章 Zend_Queue">
<link rel="chapter" href="zend.reflection.html" title="第 43 章 Zend_Reflection">
<link rel="chapter" href="zend.registry.html" title="第 44 章 Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="第 45 章 Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="第 46 章 Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="第 47 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 48 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 49 章 Zend_Session">
<link rel="chapter" href="zend.soap.html" title="第 50 章 Zend_Soap">
<link rel="chapter" href="zend.tag.html" title="第 51 章 Zend_Tag">
<link rel="chapter" href="zend.test.html" title="第 52 章 Zend_Test">
<link rel="chapter" href="zend.text.html" title="第 53 章 Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="第 54 章 Zend_TimeSync">
<link rel="chapter" href="zend.tool.framework.html" title="第 55 章 Zend_Tool_Framework">
<link rel="chapter" href="zend.tool.project.html" title="第 56 章 Zend_Tool_Project">
<link rel="chapter" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="第 58 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 59 章 Zend_Validate">
<link rel="chapter" href="zend.version.html" title="第 60 章 Zend_Version">
<link rel="chapter" href="zend.view.html" title="第 61 章 Zend_View">
<link rel="chapter" href="zend.wildfire.html" title="第 62 章 Zend_Wildfire">
<link rel="chapter" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="chapter" href="zendx.console.process.unix.html" title="第 64 章 ZendX_Console_Process_Unix">
<link rel="chapter" href="zendx.jquery.html" title="第 65 章 ZendX_JQuery">
<link rel="appendix" href="requirements.html" title="附录 A. 系统需求">
<link rel="appendix" href="coding-standard.html" title="附录 B. Zend Framework 的 PHP 编码标准">
<link rel="appendix" href="doc-standard.html" title="附录 C. Zend Framework Documentation Standard">
<link rel="appendix" href="project-structure.html" title="附录 D. Recommended Project Structure for Zend Framework MVC Applications">
<link rel="appendix" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="appendix" href="copyrights.html" title="附录 F. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="subsection" href="zend.controller.request.html#zend.controller.request.introduction" title="12.4.1. 介绍">
<link rel="subsection" href="zend.controller.request.html#zend.controller.request.http" title="12.4.2. HTTP 请求">
<link rel="subsection" href="zend.controller.request.html#zend.controller.request.subclassing" title="12.4.3. 子类化请求对象">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">12.4. 请求对象</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.controller.front.html">上一页</a> </td>
<th width="60%" align="center">第 12 章 Zend_Controller</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.controller.router.html">下一页</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.request"></a>12.4. 请求对象</h2></div></div></div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.request.introduction"></a>12.4.1. 介绍</h3></div></div></div>
<p>
            请求对象是在前端控制器，路由器，分发器，以及控制类间传递的简单值对象。请求对象封装了请求的模块，控制器，动作以及可选的参数，还包括其他的请求环境，如HTTP，CLI，PHP-GTK。
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                          模块名可通过<code class="code">getModuleName()</code>和<code class="code">setModuleName()</code>访问。
            </p></li>
<li><p>
                                控制器名可通过<code class="code">getControllerName()</code>和<code class="code">setControllerName()</code>访问。
            </p></li>
<li><p>
                          控制器调用的动作名称可通过<code class="code">getActionName()</code>和<code class="code">setActionName()</code>访问。
            </p></li>
<li><p>
                          可访问的参数是一个键值对的关联数组。数组可通过<code class="code">getParams()</code>和 <code class="code">setParams()</code>获取及设置，单个参数可以通过 <code class="code">getParam()</code> 和 <code class="code">setParam()</code>获取及设置。
            </p></li>
</ul></div>
<p>
           基于请求的类型存在更多的可用方法。默认的<code class="code">Zend_Controller_Request_Http</code>请求对象，拥有访问请求url、路径信息、<code class="code">$_GET</code> 和 <code class="code">$_POST</code>参数的方法等等。
        </p>
<p>
            请求对象先被传入到前端控制器。如果没有提供请求对象，它将在分发过程的开始、任何路由过程发生之前实例化。请求对象将被传递到分发链中的每个对象。
        </p>
<p>
           而且，请求对象在测试中是很有用的。开发人员可根据需要搭建请求环境，包括模块、控制器、动作、参数、URI等等，并且将其传入前端控制器来测试程序流向。如果与<a href="zend.controller.response.html" title="12.9. 响应对象">响应对象</a>配合，可以对MVC程序进行精确巧妙的单元测试(<code class="code">unit testing</code>)。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.request.http"></a>12.4.2. HTTP 请求</h3></div></div></div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.request.http.dataacess"></a>12.4.2.1. 访问请求数据</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code>封装了对相关值的访问，如控制器和动作路由器变量的键名和值，从URL解析的附加参数。它还允许访问作为公共成员的超全局变量，管理当前的基地址(Base URL)和请求URI。超全局变量不能在请求对象中赋值，但可以通过setParam/getParam方法设定/获取用户参数。
            </p>
<div class="note"><table border="0" summary="Note: 超全局数据">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">超全局数据</th>
</tr>
<tr><td align="left" valign="top"><p>
                    通过<code class="code">Zend_Controller_Request_Http</code>访问公共成员属性的超全局数据,有必要认识到一点，这些属性名(超全局数组的键)按照特定次序匹配超全局变量：1. GET，2.POST，3. COOKIE，4. SERVER，5. ENV。
                </p></td></tr>
</table></div>
<p>
               特定的超全局变量也可以选择特定的方法来访问，如<code class="code">$_POST['user']</code>可以调用请求对象的<code class="code">getPost('user')</code>访问，<code class="code">getQuery()</code>可以获取<code class="code">$_GET</code>元素，<code class="code">getHeader()</code>可以获取请求消息头。
            </p>
<div class="note"><table border="0" summary="Note: GET和POST数据">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">GET和POST数据</th>
</tr>
<tr><td align="left" valign="top"><p>
                    需要注意：在请求对象中访问数据是没有经过任何过滤的，路由器和分发器根据任务来验证过滤数据，但在请求对象中没有任何处理。
                </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note:  也获取原始 （Raw） POST 数据！">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 也获取原始 （Raw） POST 数据！</th>
</tr>
<tr><td align="left" valign="top">
<p>
                    从 1.5.0 开始，也可以通过 <code class="code">getRawBody()</code>  方法获取原始 post 数据。如果没有数据以那种方式提交，该方法返回 false，但 post 的全体（full boday）是个例外。
                </p>
<p>
                    当开发一个 RESTful MVC 程序，这个对于接受内容相当有用。
                </p>
</td></tr>
</table></div>
<p>
               可以在请求对象中使用<code class="code">setParam()</code> 和<code class="code">getParam()</code>来设置和获取用户参数。 路由器根据请求URI中的参数，利用这项功能请求对象设定参数。
            </p>
<div class="note"><table border="0" summary="Note: getParam()不只可以获取用户参数">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">getParam()不只可以获取用户参数</th>
</tr>
<tr><td align="left" valign="top"><p>
                    <code class="code">getParam()</code>事实上从几个资源中获取参数。根据优先级排序：通过<code class="code">setParam()</code>设置的用户参数，<code class="code">GET</code> 参数，最后是<code class="code">POST</code>参数。 通过该方法获取数据时需要注意这点。
                </p></td></tr>
</table></div>
<p>
                如果你希望从你通过 <code class="code">setParam()</code> 设置的参数中获取（参数），使用 <code class="code">getUserParam()</code>。
            </p>
<p>
                 另外，从 1.5.0 开始，可以锁定搜索哪个参数源，<code class="code">setParamSources()</code> 允许指定一个空数组或者一个带有一个或多个指示哪个参数源被允许（缺省两者都被允许）的值 '_GET'或'_POST'的数组；如果想限制只访问 '_GET'，那么指定 <code class="code">setParamSources(array('_GET'))</code> 。
            </p>
<div class="note"><table border="0" summary="Note: Apache相关">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">Apache相关</th>
</tr>
<tr><td align="left" valign="top">
<p>
                        如果使用apache的404处理器来传递请求到前端控制器，或者使用重写规则(rewrite rules)的PT标志，URI包含在<code class="code">$_SERVER['REDIRECT_URL']</code>，而不是<code class="code">$_SERVER['REQUEST_URI']</code>。如果使用这样的设定并获取无效的路由，应该使用<code class="code">Zend_Controller_Request_Apache404</code>类代替默认的HTTP类：
                </p>
<pre class="programlisting">
$request = new Zend_Controller_Request_Apache404();
$front-&gt;setRequest($request);

                </pre>
<p>
                    这个类继承了<code class="code">Zend_Controller_Request_Http</code>，并简单的修改了请求URI的自动发现(autodiscovery)，它可以用来作为简易替换器件(drop-in replacement)。
                </p>
</td></tr>
</table></div>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.request.http.baseurl"></a>12.4.2.2. 基地址和子目录</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code>允许在子目录中使用<code class="code">Zend_Controller_Router_Rewrite</code>。<code class="code">Zend_Controller_Request_Http</code>试图自动的检测你的基地址，并进行相应的设置。
            </p>
<p>
                例如，如果将 <code class="code">index.php</code> 放在web服务器的名为<code class="code">/projects/myapp/index.php</code>子目录中，基地址应该被设置为<code class="code">/projects/myapp</code>。计算任何路由匹配之前将先从路径中去除这个字符串。这个字串需要被加入到任何路由前面。路由              <code class="code">'user/:username'</code>将匹配类似<code class="code">http://localhost/projects/myapp/user/martel</code> 和<code class="code">http://example.com/user/martel</code>的URL。
            </p>
<div class="note"><table border="0" summary="Note: URL检测区分大小写">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">URL检测区分大小写</th>
</tr>
<tr><td align="left" valign="top"><p>
            基地址的自动检测是区分大小写的，因此需要确保URL与文件系统中的子目录匹配。否则将会引发异常。
                </p></td></tr>
</table></div>
<p>
        如果基地址经检测不正确，可以利用<code class="code">Zend_Controller_Request_Http</code>或者<code class="code">Zend_Controller_Front</code>类的<code class="code">setBaseUrl()</code>方法设置自己的基路径。<code class="code">Zend_Controller_Front</code>设置最容易，它将导入基地址到请求对象。定制基地址的用法举例：
            </p>
<pre class="programlisting">
/**
 * Dispatch Request with custom base URL with Zend_Controller_Front.
 */
$router     = new Zend_Controller_Router_Rewrite();
$controller = Zend_Controller_Front::getInstance();
$controller-&gt;setControllerDirectory('./application/controllers')
           -&gt;setRouter($router)
           -&gt;setBaseUrl('/projects/myapp'); // set the base url!
$response   = $controller-&gt;dispatch();

            </pre>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.request.http.method"></a>12.4.2.3.  决定请求方式 </h4></div></div></div>
<p>
                <code class="code">getMethod()</code> 允许你决定用于请求当前资源的 HTTP 请求方法。另外，当询问是否一个请求的特定类型是否已经存在，有许多方法允许你获得布尔响应：
            </p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="code">isGet()</code></p></li>
<li><p><code class="code">isPost()</code></p></li>
<li><p><code class="code">isPut()</code></p></li>
<li><p><code class="code">isDelete()</code></p></li>
<li><p><code class="code">isHead()</code></p></li>
<li><p><code class="code">isOptions()</code></p></li>
</ul></div>
<p>
                这些基本用例是来创建 RESTful MVC 架构的。
            </p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.request.http.ajax"></a>12.4.2.4. 删除 AJAX 请求</h4></div></div></div>
<p>
                <code class="code">Zend_Controller_Request_Http</code> 有一个初步的方法用来检测AJAX请求：<code class="code">isXmlHttpRequest()</code>。这个方法寻找一个带有'XMLHttpRequest' 值的HTTP请求头<code class="code">X-Requested-With</code>；如果发现，就返回true。
            </p>
<p>
                当前，这个头用下列JS库缺省地传递：
            </p>
<div class="itemizedlist"><ul type="disc">
<li><p>Prototype/Scriptaculous (and libraries derived
                        from Prototype)</p></li>
<li><p>Yahoo! UI Library</p></li>
<li><p>jQuery</p></li>
<li><p>MochiKit</p></li>
</ul></div>
<p>
                大多数 AJAX 库允许发送定制的HTTP请求头；如果你的库没有发送这个头，简单地把它作为一个请求头添加上确保<code class="code">isXmlHttpRequest()</code> 方法工作。
            </p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.request.subclassing"></a>12.4.3. 子类化请求对象</h3></div></div></div>
<p>
        所有请求对象的基请求类是抽象类<code class="code">Zend_Controller_Request_Abstract</code>。定义了一些最基本的方法：
        </p>
<pre class="programlisting">
abstract class Zend_Controller_Request_Abstract
{
    /**
     * @return string
     */
    public function getControllerName();

    /**
     * @param string $value
     * @return self
     */
    public function setControllerName($value);

    /**
     * @return string
     */
    public function getActionName();

    /**
     * @param string $value
     * @return self
     */
    public function setActionName($value);

    /**
     * @return string
     */
    public function getControllerKey();

    /**
     * @param string $key
     * @return self
     */
    public function setControllerKey($key);

    /**
     * @return string
     */
    public function getActionKey();

    /**
     * @param string $key
     * @return self
     */
    public function setActionKey($key);

    /**
     * @param string $key
     * @return mixed
     */
    public function getParam($key);

    /**
     * @param string $key
     * @param mixed $value
     * @return self
     */
    public function setParam($key, $value);

    /**
     * @return array
     */
     public function getParams();

    /**
     * @param array $array
     * @return self
     */
    public function setParams(array $array);

    /**
     * @param boolean $flag
     * @return self
     */
    public function setDispatched($flag = true);

    /**
     * @return boolean
     */
    public function isDispatched();
}

        </pre>
<p>
        请求对象是请求环境的容器。控制器链实际上只需要知道如何设置和获取控制器、动作，可选的参数以及分发的状态。默认的，请求将使用controller和action键查询自己的参数来确定控制器和动作。
        </p>
<p>
        需要一个请求类来与特定的环境交互以获得需要的数据时，可以扩展该基类或它的衍生类。例如<a href="zend.controller.request.html#zend.controller.request.http" title="12.4.2. HTTP 请求">HTTP环境</a>，CLI环境，或者PHP-GTK环境。
        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.controller.front.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.controller.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.controller.router.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">12.3. 前端控制器 </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 12.5. 标准路由器</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
