<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>23.3.  使用 Zend_Form_Element 生成表单元素</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="prev" href="zend.form.quickstart.html" title="23.2. Zend_Form 快速起步">
<link rel="next" href="zend.form.forms.html" title="23.4.  使用 Zend_Form 生成表单">
<link rel="chapter" href="introduction.html" title="第 1 章 Zend Framework简介">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.amf.html" title="第 3 章 Zend_Amf">
<link rel="chapter" href="zend.application.html" title="第 4 章 Zend_Application">
<link rel="chapter" href="zend.auth.html" title="第 5 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 6 章 Zend_Cache">
<link rel="chapter" href="zend.captcha.html" title="第 7 章 Zend_Captcha">
<link rel="chapter" href="zend.codegenerator.html" title="第 8 章 Zend_CodeGenerator">
<link rel="chapter" href="zend.config.html" title="第 9 章 Zend_Config">
<link rel="chapter" href="zend.config.writer.html" title="第 10 章 Zend_Config_Writer">
<link rel="chapter" href="zend.console.getopt.html" title="第 11 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="zend.date.html" title="第 14 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 15 章 Zend_Db">
<link rel="chapter" href="zend.debug.html" title="第 16 章 Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="第 17 章 Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="第 18 章 Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="第 19 章 Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="第 20 章 Zend_Feed">
<link rel="chapter" href="zend.file.html" title="第 21 章 Zend_File">
<link rel="chapter" href="zend.filter.html" title="第 22 章 Zend_Filter">
<link rel="chapter" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="第 24 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 25 章 Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="第 26 章 Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="第 27 章 Zend_Json">
<link rel="chapter" href="zend.layout.html" title="第 28 章 Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="第 29 章 Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="第 30 章 Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="第 31 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 32 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 33 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 34 章 Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="第 35 章 Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="第 36 章 Zend_Mime">
<link rel="chapter" href="zend.navigation.html" title="第 37 章 Zend_Navigation">
<link rel="chapter" href="zend.openid.html" title="第 38 章 Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="zend.progressbar.html" title="第 41 章 Zend_ProgressBar">
<link rel="chapter" href="zend.queue.html" title="第 42 章 Zend_Queue">
<link rel="chapter" href="zend.reflection.html" title="第 43 章 Zend_Reflection">
<link rel="chapter" href="zend.registry.html" title="第 44 章 Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="第 45 章 Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="第 46 章 Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="第 47 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 48 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 49 章 Zend_Session">
<link rel="chapter" href="zend.soap.html" title="第 50 章 Zend_Soap">
<link rel="chapter" href="zend.tag.html" title="第 51 章 Zend_Tag">
<link rel="chapter" href="zend.test.html" title="第 52 章 Zend_Test">
<link rel="chapter" href="zend.text.html" title="第 53 章 Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="第 54 章 Zend_TimeSync">
<link rel="chapter" href="zend.tool.framework.html" title="第 55 章 Zend_Tool_Framework">
<link rel="chapter" href="zend.tool.project.html" title="第 56 章 Zend_Tool_Project">
<link rel="chapter" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="第 58 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 59 章 Zend_Validate">
<link rel="chapter" href="zend.version.html" title="第 60 章 Zend_Version">
<link rel="chapter" href="zend.view.html" title="第 61 章 Zend_View">
<link rel="chapter" href="zend.wildfire.html" title="第 62 章 Zend_Wildfire">
<link rel="chapter" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="chapter" href="zendx.console.process.unix.html" title="第 64 章 ZendX_Console_Process_Unix">
<link rel="chapter" href="zendx.jquery.html" title="第 65 章 ZendX_JQuery">
<link rel="appendix" href="requirements.html" title="附录 A. 系统需求">
<link rel="appendix" href="coding-standard.html" title="附录 B. Zend Framework 的 PHP 编码标准">
<link rel="appendix" href="doc-standard.html" title="附录 C. Zend Framework Documentation Standard">
<link rel="appendix" href="project-structure.html" title="附录 D. Recommended Project Structure for Zend Framework MVC Applications">
<link rel="appendix" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="appendix" href="copyrights.html" title="附录 F. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.loaders" title="23.3.1.  插件加载器">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.filters" title="23.3.2.  过滤器">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.validators" title="23.3.3.  校验器">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.decorators" title="23.3.4.  装饰器">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.metadata" title="23.3.5.  元数据和属性">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.standard" title="23.3.6.  标准元素">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.methods" title="23.3.7. Zend_Form_Element 方法">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.config" title="23.3.8.  配置">
<link rel="subsection" href="zend.form.elements.html#zend.form.elements.custom" title="23.3.9.  定制元素">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">23.3.  使用 Zend_Form_Element 生成表单元素 </th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.form.quickstart.html">上一页</a> </td>
<th width="60%" align="center">第 23 章 Zend_Form</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.form.forms.html">下一页</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.form.elements"></a>23.3.  使用 Zend_Form_Element 生成表单元素 </h2></div></div></div>
<p>
        表单由元素组成，它一般对应于 HTML 表单输入。Zend_Form_Element 封装了单个表单元素，并完成下列工作：
    </p>
<div class="itemizedlist"><ul type="disc">
<li>
<p>
                校验（提交的数据有效乎？）
            </p>
<div class="itemizedlist"><ul type="circle"><li><p> 抓取校验错误代码和消息 </p></li></ul></div>
</li>
<li><p>
            过滤（在校验和/或输出之前元素如何转义或规范化？）
        </p></li>
<li><p>
            解析（元素如何显示？）
        </p></li>
<li><p>
            元数据和属性（什么信息进一步修饰元素？）
        </p></li>
</ul></div>
<p>
        基础类 <code class="code">Zend_Form_Element</code> 对许多类有合理的缺省设置，但最好还是继承这个类来完成特殊意图的元素。另外，Zend Framework 带有许多标准的 XHTML 元素，请阅读 <a href="zend.form.standardElements.html" title="23.6. Zend Framework 带有的标准表单元素"> 在标准元素一章 </a> 的有关文档。
    </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.loaders"></a>23.3.1.  插件加载器 </h3></div></div></div>
<p>
            <code class="code">Zend_Form_Element</code> 利用 <a href="zend.loader.pluginloader.html" title="30.4.  加载插件">Zend_Loader_PluginLoader</a> 来使开发者指定替代校验器、过滤器和装饰器的位置。每个都有它自己携带的插件加载器，并使用通用的访问器来读取或修改它们。
        </p>
<p>
            下列加载器类型和各种各样的插件加载器方法一起使用：'validate'、 'filter' 和 'decorator'。类型名是大小写敏感的。
        </p>
<p>
            和插件加载器交互使用的方法如下：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <code class="code">setPluginLoader($loader, $type)</code>：<code class="code">$loader</code> 是插件加载器对象自己，而  <code class="code">$type</code> 是上述类型之一。这个方法为给定类型的插件加载器设置为最新的特定的载器对象。
            </p></li>
<li><p>
                <code class="code">getPluginLoader($type)</code>: 用携带的 <code class="code">$type</code> 来读取插件加载器。
            </p></li>
<li><p>
                <code class="code">addPrefixPath($prefix, $path, $type = null)</code>: 添加 prefix/path 联合给由 <code class="code">$type</code> 指定的加载器。如果 <code class="code">$type</code> 是 null，它将尝试通过追加前缀给 "_Validate"、"_Filter", 和 "_Decorator" 来添加路径到所有加载器，并用 "Validate/"、"Filter/" 和 "Decorator/".  追加路径。如果你在通用的等级下有所有额外的表单元素类，这是个用来设置基础前缀给它们的方便的方法。
            </p></li>
<li><p>
                <code class="code">addPrefixPaths(array $spec)</code>: 让你一次性添加许多路径给一个或多个插件加载器。它需要每个数组条目是个带有 'path'、'prefix' 和 'type'. 键的数组。
            </p></li>
</ul></div>
<p>
            定制的校验器、过滤器和装饰器是在表单和封装定制功能之间共享功能的简单的办法。
        </p>
<div class="example">
<a name="zend.form.elements.loaders.customLabel"></a><p class="title"><b>例 23.1.  定制标签 </b></p>
<div class="example-contents">
<p>
                插件的一个普通用例是来为标准类提供替换。例如，如果想实现一个不同的 'Label' 装饰器 －－ 如总要追加冒号 －－你可以创建你自己的带有类前缀的 'Label' 装饰器，然后把它加到你的前缀路径。
            </p>
<p>
                让我们从定制标签装饰器来开始，给它一个类前缀 "My_Decorator"，类文件就是 "My/Decorator/Label.php"。
            </p>
<pre class="programlisting">&lt;?php
class My_Decorator_Label extends Zend_Form_Decorator_Abstract
{
    protected $_placement = 'PREPEND';

    public function render($content)
    {
        if (null === ($element = $this-&gt;getElement())) {
            return $content;
        }
        if (!method_exists($element, 'getLabel')) {
            return $content;
        }

        $label = $element-&gt;getLabel() . ':';

        if (null === ($view = $element-&gt;getView())) {
            return $this-&gt;renderLabel($content, $label);
        }

        $label = $view-&gt;formLabel($element-&gt;getName(), $label);

        return $this-&gt;renderLabel($content, $label);
    }

    public function renderLabel($content, $label)
    {
        $placement = $this-&gt;getPlacement();
        $separator = $this-&gt;getSeparator();

        switch ($placement) {
            case 'APPEND':
                return $content . $separator . $label;
            case 'PREPEND':
            default:
                return $label . $separator . $content;
        }
    }
}
</pre>
<p>
                现在，当元素寻找装饰器时，就使用这个插件路径：
            </p>
<pre class="programlisting">
$element-&gt;addPrefixPath('My_Decorator', 'My/Decorator/', 'decorator');
</pre>
<p>
                另外，我们可以在表单一级来做以确保所有的装饰器使用这个路径：
            </p>
<pre class="programlisting">
$form-&gt;addElementPrefixPath('My_Decorator', 'My/Decorator/', 'decorator');
</pre>
<p>
                用这个添加的路径，当添加一个装饰器，将首先搜索 'My/Decorator/' 路径来检查是否存在装饰器。结果，如果请求 'Label' 装饰器，'My_Decorator_Label' 将被使用。
            </p>
</div>
</div>
<br class="example-break">
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.filters"></a>23.3.2.  过滤器 </h3></div></div></div>
<p>
            在校验之前对输入执行规范化常常是有用的并/或必需的 － 例如，你可能想要剥离所有 HTML，在剩下的东东上运行校验来确保提交有效。或者你可能想把输入的数据两边的空格都消掉，这样 StringLength 校验器就不会返回失败。这些操作使用 <code class="code">Zend_Filter</code> 来执行，并且 <code class="code">Zend_Form_Element</code> 对过滤链有支持，让你指定多个连续的过滤器来用。在校验期间和通过 <code class="code">getValue()</code> 读取元素值的时候都会发生校验：
        </p>
<pre class="programlisting">&lt;?php
$filtered = $element-&gt;getValue();
?&gt;</pre>
<p>
            有两个办法添加过滤器：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                传递一个具体的过滤器实例
            </p></li>
<li><p>
                提供过滤器名称 － 短名或完整的类名都可以
            </p></li>
</ul></div>
<p>
            看一些例子：
        </p>
<pre class="programlisting">&lt;?php
// 具体的过滤器实例：
$element-&gt;addFilter(new Zend_Filter_Alnum());

// 合格的全类名：
$element-&gt;addFilter('Zend_Filter_Alnum');

// 短过滤器名：
$element-&gt;addFilter('Alnum');
$element-&gt;addFilter('alnum');
?&gt;</pre>
<p>
            短名一般就是过滤器名去掉前缀，缺省就是去掉 'Zend_Filter_' 前缀。另外，首字母不需要大写。
        </p>
<div class="note"><table border="0" summary="Note:  使用定制的过滤器类 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 使用定制的过滤器类 </th>
</tr>
<tr><td align="left" valign="top">
<p>
                如果你有自己的一组过滤器，可以通过 <code class="code">addPrefixPath()</code> 来告诉 <code class="code">Zend_Form_Element</code>。例如，如果你在 'My_Filter' 前缀下有过滤器，这样来告诉  <code class="code">Zend_Form_Element</code>：
            </p>
<pre class="programlisting">&lt;?php
$element-&gt;addPrefixPath('My_Filter', 'My/Filter/', 'filter');
?&gt;</pre>
<p>
                （回忆一下第三个参数用来指示哪个是执行这个动作的插件加载器）
            </p>
</td></tr>
</table></div>
<p>
            任何时候需要非过滤的数据，使用 <code class="code">getUnfilteredValue()</code> 方法：
        </p>
<pre class="programlisting">&lt;?php
$unfiltered = $element-&gt;getUnfilteredValue();
?&gt;</pre>
<p>
            参见 <a href="zend.filter.html#zend.filter.introduction" title="22.1.  简介">Zend_Filter 文档 </a> 有更多关于过滤器的信息。
        </p>
<p>
            过滤器带有这些方法：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <code class="code">addFilter($nameOfFilter, array $options = null)</code>
            </p></li>
<li><p>
                <code class="code">addFilters(array $filters)</code>
            </p></li>
<li><p>
                <code class="code">setFilters(array $filters)</code> （重写所有过滤器）
            </p></li>
<li><p>
                <code class="code">getFilter($name)</code> （按名字读取过滤器对象）
            </p></li>
<li><p>
                <code class="code">getFilters()</code> （读取所有过滤器）
            </p></li>
<li><p>
                <code class="code">removeFilter($name)</code> （按名字删除过滤器）
            </p></li>
<li><p>
                <code class="code">clearFilters()</code> （删除所有过滤器）
            </p></li>
</ul></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.validators"></a>23.3.3.  校验器 </h3></div></div></div>
<p>
            如果你赞同安全咒语“过滤输入，转义输出”，你将会校验（“过滤输入”）你的表单输入。 在 <code class="code">Zend_Form</code> 里，每个元素包含它自己的由 <code class="code">Zend_Validate_*</code> 校验器组成的校验器链。
        </p>
<p>
            两个办法添加校验器到校验器链：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                传递一个具体的校验器实例
            </p></li>
<li><p>
                提供一个校验器名 － 短名或者完整的类名都可以
            </p></li>
</ul></div>
<p>
            看一些例子：
        </p>
<pre class="programlisting">&lt;?php
// Concrete validator instance:
$element-&gt;addValidator(new Zend_Validate_Alnum());

// Fully qualified class name:
$element-&gt;addValidator('Zend_Validate_Alnum');

// Short validator name:
$element-&gt;addValidator('Alnum');
$element-&gt;addValidator('alnum');
?&gt;</pre>
<p>
            短名一般就是校验器名去掉前缀，缺省就是去掉 'Zend_Validate_' 前缀。另外，首字母不需要大写。
        </p>
<div class="note"><table border="0" summary="Note:  使用定制的校验器类 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 使用定制的校验器类 </th>
</tr>
<tr><td align="left" valign="top">
<p>
                如果你有自己的一组校验器，可以通过 <code class="code">addPrefixPath()</code> 来告诉 <code class="code">Zend_Form_Element</code>。例如，如果你在 'My_Validator' 前缀下有校验器，这样来告诉  <code class="code">Zend_Form_Element</code>：
            </p>
<pre class="programlisting">&lt;?php
$element-&gt;addPrefixPath('My_Validator', 'My/Validator/', 'validate');
?&gt;</pre>
<p>
                （回忆一下第三个参数用来指示哪个是执行这个动作的插件加载器）
            </p>
</td></tr>
</table></div>
<p>
            如果特定的校验失败，为阻止后面的校验工作，传递第二个参数 <code class="code">true</code> （布尔型）：
        </p>
<pre class="programlisting">&lt;?php
$element-&gt;addValidator('alnum', true);
?&gt;</pre>
<p>
            如果你使用一个字符串名来添加一个校验器，并且这个校验器接受参数给构造器，你可以把这个第三个参数 <code class="code">addValidator()</code> 作为数组传递：
        </p>
<pre class="programlisting">&lt;?php
$element-&gt;addValidator('StringLength', false, array(6, 20));
?&gt;</pre>
<p>
            这样传递参数应该按照它们在构造器里定义的顺序进行。上述例子将带参数 <code class="code">$min</code> 和 <code class="code">$max</code> 实例化 <code class="code">Zend_Validate_StringLenth</code> 类：
        </p>
<pre class="programlisting">&lt;?php
$validator = new Zend_Validate_StringLength(6, 20);
?&gt;</pre>
<div class="note"><table border="0" summary="Note:  提供定制的校验错误消息 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 提供定制的校验错误消息 </th>
</tr>
<tr><td align="left" valign="top">
<p>
                有些开发者可能想为校验器提供定制的错误消息。 <code class="code">Zend_Form_Element::addValidator()</code> 的 <code class="code">$options</code> 参数让你通过提供 'messages' 键并把它设置为键/值对（用来设置消息模板）的数组来完成。你需要知道特定校验器的各种各样的校验错误类型的错误代码。
            </p>
<p>
                稍好的选择是在表单中使用 <code class="code">Zend_Translate_Adapter</code>。错误代码通过缺省的错误装饰器自动传递给适配器，然后你可以通过为你的校验器的各种错误代码设置翻译来指定自己的错误消息字符串。
            </p>
</td></tr>
</table></div>
<p>
            你也可以使用 <code class="code">addValidators()</code> 一次性设置许多校验器。基本的用法是传递数组的数组，每个数组包含 1 到 3 个匹配 <code class="code">addValidator()</code> 的构造器的值：
        </p>
<pre class="programlisting">&lt;?php
$element-&gt;addValidators(array(
    array('NotEmpty', true),
    array('alnum'),
    array('stringLength', false, array(6, 20)),
));
?&gt;</pre>
<p>
            如果你想做的更明确和更详细，可以使用数组键 'validator'、 'breakChainOnFailure' 和 'options'：
        </p>
<pre class="programlisting">&lt;?php
$element-&gt;addValidators(array(
    array(
        'validator'           =&gt; 'NotEmpty',
        'breakChainOnFailure' =&gt; true),
    array('validator' =&gt; 'alnum'),
    array(
        'validator' =&gt; 'stringLength',
        'options'   =&gt; array(6, 20)),
));
?&gt;</pre>
<p>
            这个用法展示如何在配置文件中配置校验器：
        </p>
<pre class="programlisting">
element.validators.notempty.validator = "NotEmpty"
element.validators.notempty.breakChainOnFailure = true
element.validators.alnum.validator = "Alnum"
element.validators.strlen.validator = "StringLength"
element.validators.strlen.options.min = 6
element.validators.strlen.options.max = 20
</pre>
<p>
            注意每个条目有一个键，不管是否需要，这是使用配置文件规定的 －－但它也帮助清楚理解哪个参数用于什么。请记住任何校验器选项必需按顺序指定。
        </p>
<p>
            为校验一个元素，传递值给 <code class="code">isValid()</code>：
        </p>
<pre class="programlisting">&lt;?php
if ($element-&gt;isValid($value)) {
    // valid
} else {
    // invalid
}
?&gt;</pre>
<div class="note"><table border="0" summary="Note:  在过滤后的值上校验 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 在过滤后的值上校验 </th>
</tr>
<tr><td align="left" valign="top"><p>
                <code class="code">Zend_Form_Element::isValid()</code> 在校验之前通过提供过滤器链来过滤（输入）值。见 See <a href="zend.form.elements.html#zend.form.elements.filters" title="23.3.2.  过滤器"> 过滤器一节 </a> 有更多信息。
            </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note:  校验上下文 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 校验上下文 </th>
</tr>
<tr><td align="left" valign="top">
<p>
                <code class="code">Zend_Form_Element::isValid()</code> 支持另外的参数 <code class="code">$context</code>。当校验一个表单 <code class="code">Zend_Form::isValid()</code> 传递由 <code class="code">$context</code> 处理过的数据的整个数组，<code class="code">Zend_Form_Element::isValid()</code> 接着把它传递给每个校验器。这意味着你可以写知道数据传递给其它表单元素的校验器，例如，标准的注册表单有密码和密码确认元素，得有一个校验它们是否匹配。这样的校验器看起来如下：
            </p>
<pre class="programlisting">&lt;?php
class My_Validate_PasswordConfirmation extends Zend_Validate_Abstract
{
    const NOT_MATCH = 'notMatch';

    protected $_messageTemplates = array(
        self::NOT_MATCH =&gt; 'Password confirmation does not match'
    );

    public function isValid($value, $context = null)
    {
        $value = (string) $value;
        $this-&gt;_setValue($value);

        if (is_array($context)) {
            if (isset($context['password_confirm'])
                &amp;&amp; ($value == $context['password_confirm']))
            {
                return true;
            }
        } elseif (is_string($context) &amp;&amp; ($value == $context)) {
            return true;
        }

        $this-&gt;_error(self::NOT_MATCH);
        return false;
    }
}
?&gt;</pre>
</td></tr>
</table></div>
<p>
            校验器按顺序处理，除非用 <code class="code">breakChainOnFailure</code> 为 true 创建的校验器并且校验失败，否则每个校验器都要处理。确认按合理的顺序指定你的校验器。
        </p>
<p>
            校验失败后，你可以从校验器链读取错误代码和消息：
        </p>
<pre class="programlisting">&lt;?php
$errors   = $element-&gt;getErrors();
$messages = $element-&gt;getMessages();
?&gt;</pre>
<p>
            （注意：错误消息返回的是一个有错误代码/错误消息对的联合数组）
        </p>
<p>
            除了校验器外，你可以用 <code class="code">setRequired(true)</code> 指定必需的元素。缺省地，这个标志是 false，如果没有值传递给 <code class="code">isValid()</code>，校验器链将被跳过。你也可以用许多办法来修改它的行为：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    缺省地，当元素是必需的，标志 'allowEmpty'也是 true。这意味着如果传递给 <code class="code">isValid()</code> 的值为空，校验器将被跳过。可以用访问器 <code class="code">setAllowEmpty($flag)</code> 来切换这个标志。当标志为 false，并且传递了一个值，校验器将仍然运行。
                </p></li>
<li>
<p>
                    缺省地，如果元素是必需的，但不包括 'NotEmpty' 校验器，<code class="code">isValid()</code> 就用 <code class="code">breakChainOnFailure</code> 标志设置添加一个到栈顶。这使得要求的标志有语义意义：如果没有传递值，我们立即使提交的数据无效并通知用户，并防止其它校验器继续校验我们已知的无效数据。
                </p>
<p>
                    如果你不想这样，传递给 <code class="code">setAutoInsertNotEmptyValidator($flag)</code> 一个 false 值使它关闭。这将防止 <code class="code">isValid()</code> 在校验器链里放置一个 'NotEmpty' 校验器。
                </p>
</li>
</ul></div>
<p>
            关于校验器的更多信息，参见 <a href="zend.validate.html#zend.validate.introduction" title="59.1.  简介">Zend_Validate 文档 </a>。
        </p>
<div class="note"><table border="0" summary="Note:  使用 Zend_Form_Elements 作为通用的校验器 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 使用 Zend_Form_Elements 作为通用的校验器 </th>
</tr>
<tr><td align="left" valign="top"><p>
                <code class="code">Zend_Form_Element</code> 实现 <code class="code">Zend_Validate_Interface</code>，意味着元素可以在其它非表单相关的校验链里被用做校验器。
            </p></td></tr>
</table></div>
<p>
            校验相关的方法包括：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">setRequired($flag)</code> 和 <code class="code">isRequired()</code> 让你设置和读取 'required' 标志的状态。当设置为布尔 <code class="code">true</code>，这个标志要求元素在由 <code class="code">Zend_Form</code> 处理的数据中。
            </p></li>
<li><p>
                    <code class="code">setAllowEmpty($flag)</code> 和 <code class="code">getAllowEmpty()</code> 让你修改可选元素的行为（例如，要求的标志为 false 的元素）。当 'allow empty' 标志为 true 时，空值将传递给校验器链。
            </p></li>
<li><p>
                    <code class="code">setAutoInsertNotEmptyValidator($flag)</code> 当元素是必需时，让你指定是否 'NotEmpty' 校验器预先准备给校验器链。缺省地，这个标志为 true 。
            </p></li>
<li><p>
                <code class="code">addValidator($nameOrValidator, $breakChainOnFailure = false, array $options = null)</code>
            </p></li>
<li><p>
                <code class="code">addValidators(array $validators)</code>
            </p></li>
<li><p>
                <code class="code">setValidators(array $validators)</code> （重写所有校验器）
            </p></li>
<li><p>
                <code class="code">getValidator($name)</code> （按名读取校验器对象）
            </p></li>
<li><p>
                <code class="code">getValidators()</code> （读取所有校验器）
            </p></li>
<li><p>
                <code class="code">removeValidator($name)</code> （按名删除校验器）
            </p></li>
<li><p>
                <code class="code">clearValidators()</code> （删除所有校验器）
            </p></li>
</ul></div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.form.elements.validators.errors"></a>23.3.3.1.  定制错误消息 </h4></div></div></div>
<p>
                有时，你想定制一条或多条特定的错误消息来替代由附加到元素上的校验器所带的错误消息。
                另外，有时候你想自己标记表单无效，从 1.6.0 版开始，通过下列方法来实现这个功能。
            </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">addErrorMessage($message)</code>: 添加一条来显示当校验失败时的错误消息。
                    可以多次调用，新消息就追加到堆栈。
                </p></li>
<li><p>
                    <code class="code">addErrorMessages(array $messages)</code>: 添加多条错误消息来显示校验错误。
                </p></li>
<li><p>
                    <code class="code">setErrorMessages(array $messages)</code>: 添加多条错误消息来显示校验错误，并覆盖先前的错误消息。
                </p></li>
<li><p>
                    <code class="code">getErrorMessages()</code>: 读取已定义的定制的错误消息列表。
                </p></li>
<li><p>
                    <code class="code">clearErrorMessages()</code>: 删除已定义的定制的错误消息。
                </p></li>
<li><p>
                    <code class="code">markAsError()</code>: 标记表单已经有失败的校验。
                </p></li>
<li><p>
                    <code class="code">hasErrors()</code>: 确定是否元素有失败校验或标记为无效。
          </p></li>
<li><p>
                    <code class="code">addError($message)</code>: 添加一条消息给定制错误消息栈并标记表单无效。
                </p></li>
<li><p>
                    <code class="code">addErrors(array $messages)</code>: 添加数条消息给定制错误消息栈并标记表单无效。
                </p></li>
<li><p>
                    <code class="code">setErrors(array $messages)</code>: 覆盖定制的错误消息堆栈并标记表单无效。
                </p></li>
</ul></div>
<p>
                所有用这个方式设置的错误可以被翻译。
            </p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.decorators"></a>23.3.4.  装饰器 </h3></div></div></div>
<p>
            对许多 web 开发者来说一个特别的痛苦是 XHTML 表单自己的生成。对于每个元素，开发者需要为元素自己生成 markup，label 是一个典型，并且，如果他们对用户很好，需要为显示校验错误消息生成 markup。在页面元素越多，任务就越不琐碎。
        </p>
<p>
            <code class="code">Zend_Form_Element</code> 试图用 "装饰器" 来解决这个问题。装饰器就是个类，可以访问元素和用于解析内容的方法。更多关于装饰器如何工作，参见 <a href="zend.form.decorators.html" title="23.5.  使用 Zend_Form_Decorator 生成定制的表单标识（Markup）">Zend_Form_Decorator</a>。
        </p>
<p>
            <code class="code">Zend_Form_Element</code> 所使用的缺省的装饰器是：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <span class="emphasis"><em>ViewHelper</em></span>: 指定一个视图助手用于解析元素。'helper' 元素属性可用来指定使用哪个视图助手。缺省地，<code class="code">Zend_Form_Element</code> 指定 'formText' 视图助手，但个别的子类指定不同的助手。
            </p></li>
<li><p>
                <span class="emphasis"><em>Errors</em></span>: 使用 <code class="code">Zend_View_Helper_FormErrors</code> 追加错误消息给元素，如果没有错误，就不追加。
            </p></li>
<li><p>
                <span class="emphasis"><em>HtmlTag</em></span>: 在一个 HTML &lt;dd&gt; 标签里封装元素和错误。
            </p></li>
<li><p>
                <span class="emphasis"><em>Label</em></span>: 使用 <code class="code">Zend_View_Helper_FormLabel</code> 预先准备一个标签给元素，并把它封装在一个 &lt;dt&gt; 标签里。如果没有提供标签（Label），就解析定义术语（definition term）标签（tag）。
            </p></li>
</ul></div>
<div class="note"><table border="0" summary="Note:  不需要加载缺省装饰器 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 不需要加载缺省装饰器 </th>
</tr>
<tr><td align="left" valign="top">
<p>
                缺省地，在对象初始化过程中加载缺省装饰器。你可以通过传递 'disableLoadDefaultDecorators' 选项给构造器来关闭它：
            </p>
<pre class="programlisting">&lt;?php
$element = new Zend_Form_Element('foo', array('disableLoadDefaultDecorators' =&gt; true));
</pre>
<p>
                该选项可以和企图选项混合，它们都是数组选项或在 <code class="code">Zend_Config</code> 对象里。
            </p>
</td></tr>
</table></div>
<p>
            因为装饰器注册顺序的原因 －－先注册先执行－－你需要确保按合适的顺序来注册装饰器，或者确保以健全的方式设置替换选项。这个是注册缺省装饰器的例子：
        </p>
<pre class="programlisting">&lt;?php
$this-&gt;addDecorators(array(
    array('ViewHelper'),
    array('Errors'),
    array('HtmlTag', array('tag' =&gt; 'dd')),
    array('Label', array('tag' =&gt; 'dt')),
));
?&gt;</pre>
<p>
            初始内容由 'ViewHelper' 装饰器生成，它生成表单元素自己。接着，'Errors' 装饰器从元素里抓取错误消息。如果有任何错误，就传递给 'FormErrors' 视图助手来解析。下一个装饰器 'HtmlTag' 在一个 HTML &lt;dd&gt; 标签里封装元素和错误。最后，'label' 装饰器读取元素的标签并传递给 'FormLabel' 视图助手，封装在一个 HTML &lt;dt&gt; 标签里。缺省地，数据预先准备给内容，输出结果基本上是这样的：
        </p>
<pre class="programlisting">
&lt;dt&gt;&lt;label for="foo" class="optional"&gt;Foo&lt;/label&gt;&lt;/dt&gt;
&lt;dd&gt;
    &lt;input type="text" name="foo" id="foo" value="123" /&gt;
    &lt;ul class="errors"&gt;
        &lt;li&gt;"123" is not an alphanumeric value&lt;/li&gt;
    &lt;/ul&gt;
&lt;/dd&gt;
</pre>
<p>
            关于装饰器的更多信息，请阅读 <a href="zend.form.decorators.html" title="23.5.  使用 Zend_Form_Decorator 生成定制的表单标识（Markup）">Zend_Form_Decorator 一节</a>。
        </p>
<div class="note"><table border="0" summary="Note:  使用同类型的多重装饰器 ">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left"> 使用同类型的多重装饰器 </th>
</tr>
<tr><td align="left" valign="top">
<p>
                在内部，当读取装饰器时，<code class="code">Zend_Form_Element</code> 使用装饰器的类作为查询机制。结果，你不能注册同类型的多重装饰器，后来的装饰器就重写以前存在的装饰器。
            </p>
<p>
                为解决这个问题，你可以使用 <span class="emphasis"><em>aliases</em></span>。不是传递装饰器或装饰器名作为第一个参数给 <code class="code">addDecorator()</code>，而是传递带有一个单个元素的数组，并且别名指向装饰器对象或名字：
            </p>
<pre class="programlisting">&lt;?php
// Alias to 'FooBar':
$element-&gt;addDecorator(array('FooBar' =&gt; 'HtmlTag'), array('tag' =&gt; 'div'));

// And retrieve later:
$decorator = $element-&gt;getDecorator('FooBar');
?&gt;</pre>
<p>
                在 <code class="code">addDecorators()</code> 和 <code class="code">setDecorators()</code> 方法中，你需要在表示装饰器的数组中传递 'decorator' 选项：
            </p>
<pre class="programlisting">&lt;?php
// Add two 'HtmlTag' decorators, aliasing one to 'FooBar':
$element-&gt;addDecorators(
    array('HtmlTag', array('tag' =&gt; 'div')),
    array(
        'decorator' =&gt; array('FooBar' =&gt; 'HtmlTag'),
        'options' =&gt; array('tag' =&gt; 'dd')
    ),
);

// And retrieve later:
$htmlTag = $element-&gt;getDecorator('HtmlTag');
$fooBar  = $element-&gt;getDecorator('FooBar');
?&gt;</pre>
</td></tr>
</table></div>
<p>
            装饰器带有的方法包括：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <code class="code">addDecorator($nameOrDecorator, array $options = null)</code>
            </p></li>
<li><p>
                <code class="code">addDecorators(array $decorators)</code>
            </p></li>
<li><p>
                <code class="code">setDecorators(array $decorators)</code> （重写所有装饰器）
            </p></li>
<li><p>
                <code class="code">getDecorator($name)</code> （按名读取装饰器对象）
            </p></li>
<li><p>
                <code class="code">getDecorators()</code> （读取所有装饰器）
            </p></li>
<li><p>
                <code class="code">removeDecorator($name)</code> （按名删除装饰器）
            </p></li>
<li><p>
                <code class="code">clearDecorators()</code> （删除所有装饰器）
            </p></li>
</ul></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.metadata"></a>23.3.5.  元数据和属性 </h3></div></div></div>
<p>
            <code class="code">Zend_Form_Element</code> 处理广泛的属性和元素元数据，基本属性包括：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <span class="emphasis"><em>name</em></span>: 元素名，使用 <code class="code">setName()</code> 和 <code class="code">getName()</code> 访问器。
            </p></li>
<li><p>
                <span class="emphasis"><em>label</em></span>: 元素标签，使用 <code class="code">setLabel()</code> 和 <code class="code">getLabel()</code> 访问器。
            </p></li>
<li><p>
                <span class="emphasis"><em>order</em></span>: 在表单中出现的元素的索引，使用 <code class="code">setOrder()</code> 和 <code class="code">getOrder()</code> 访问器。
            </p></li>
<li><p>
                <span class="emphasis"><em>value</em></span>: 当前元素的值，使用 <code class="code">setValue()</code> 和 <code class="code">getValue()</code> 访问器。
            </p></li>
<li><p>
                <span class="emphasis"><em>description</em></span>: 元素的描述，常用于提供工具提示或 javascript 上下文提示，描述元素的意图，使用 <code class="code">setDescription()</code> 和 <code class="code">getDescription()</code> 访问器。
            </p></li>
<li><p>
                <span class="emphasis"><em>required</em></span>: 当执行表单校验时，指示元素是否必需的标志，使用 <code class="code">setRequired()</code> 和 <code class="code">getRequired()</code> 访问器，缺省为 false。
            </p></li>
<li><p>
                <span class="emphasis"><em>allowEmpty</em></span>: 指示可选的元素是否应该校验空值的标志，当为 true，并且要求的标志为 false，空值就不传递给校验器链，并假定为 true。使用 <code class="code">setAllowEmpty()</code> 和 <code class="code">getAllowEmpty()</code> 访问器，缺省为 true。
            </p></li>
<li><p>
                <span class="emphasis"><em>autoInsertNotEmptyValidator</em></span>: 当元素是必需时，指示是否插入一个 'NotEmpty' 校验器。缺省地，这个标志为 true，用 <code class="code">setAutoInsertNotEmptyValidator($flag)</code> 来设置该标志并用 <code class="code">autoInsertNotEmptyValidator()</code> 来确定它的值。
            </p></li>
</ul></div>
<p>
            表单元素可能要求另外的元数据。例如，对于 XHTML 表单元素，你可能想指定属性如类或 id，有一组访问器来完成它：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <span class="emphasis"><em>setAttrib($name, $value)</em></span>: 添加属性
            </p></li>
<li><p>
                <span class="emphasis"><em>setAttribs(array $attribs)</em></span>: 像 addAttribs() 一样，但重写
            </p></li>
<li><p>
                <span class="emphasis"><em>getAttrib($name)</em></span>: 读取一个单个的属性值
            </p></li>
<li><p>
                <span class="emphasis"><em>getAttribs()</em></span>: 以键/值对读取所有属性
            </p></li>
</ul></div>
<p>
            然而大多数时候，你可以把它们当作对象属性来访问，因为 <code class="code">Zend_Form_Element</code> 利用重载来简便访问它们：
        </p>
<pre class="programlisting">&lt;?php
// Equivalent to $element-&gt;setAttrib('class', 'text'):
$element-&gt;class = 'text;
?&gt;</pre>
<p>
            缺省地，在解析过程中所有属性传递给由元素使用的视图助手，并当作该元素标签的 HTML 属性来解析。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.standard"></a>23.3.6.  标准元素 </h3></div></div></div>
<p>
            <code class="code">Zend_Form</code> 带有许多标准元素，请阅读 <a href="zend.form.standardElements.html" title="23.6. Zend Framework 带有的标准表单元素"> 标准元素 </a> 一章有全部细节。
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.methods"></a>23.3.7. Zend_Form_Element 方法 </h3></div></div></div>
<p>
            <code class="code">Zend_Form_Element</code> 有许多许多方法。下面是一个快速概要，按类分组：
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
<p>配置：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="code">setOptions(array $options)</code></p></li>
<li><p><code class="code">setConfig(Zend_Config $config)</code></p></li>
</ul></div>
</li>
<li>
<p>I18n:</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="code">setTranslator(Zend_Translate_Adapter $translator = null)</code></p></li>
<li><p><code class="code">getTranslator()</code></p></li>
<li><p><code class="code">setDisableTranslator($flag)</code></p></li>
<li><p><code class="code">translatorIsDisabled()</code></p></li>
</ul></div>
</li>
<li>
<p> 属性：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="code">setName($name)</code></p></li>
<li><p><code class="code">getName()</code></p></li>
<li><p><code class="code">setValue($value)</code></p></li>
<li><p><code class="code">getValue()</code></p></li>
<li><p><code class="code">getUnfilteredValue()</code></p></li>
<li><p><code class="code">setLabel($label)</code></p></li>
<li><p><code class="code">getLabel()</code></p></li>
<li><p><code class="code">setDescription($description)</code></p></li>
<li><p><code class="code">getDescription()</code></p></li>
<li><p><code class="code">setOrder($order)</code></p></li>
<li><p><code class="code">getOrder()</code></p></li>
<li><p><code class="code">setRequired($flag)</code></p></li>
<li><p><code class="code">getRequired()</code></p></li>
<li><p><code class="code">setAllowEmpty($flag)</code></p></li>
<li><p><code class="code">getAllowEmpty()</code></p></li>
<li><p><code class="code">setAutoInsertNotEmptyValidator($flag)</code></p></li>
<li><p><code class="code">autoInsertNotEmptyValidator()</code></p></li>
<li><p><code class="code">setIgnore($flag)</code></p></li>
<li><p><code class="code">getIgnore()</code></p></li>
<li><p><code class="code">getType()</code></p></li>
<li><p><code class="code">setAttrib($name, $value)</code></p></li>
<li><p><code class="code">setAttribs(array $attribs)</code></p></li>
<li><p><code class="code">getAttrib($name)</code></p></li>
<li><p><code class="code">getAttribs()</code></p></li>
</ul></div>
</li>
<li>
<p> 插件加载器和路径：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="code">setPluginLoader(Zend_Loader_PluginLoader_Interface $loader, $type)</code></p></li>
<li><p><code class="code">getPluginLoader($type)</code></p></li>
<li><p><code class="code">addPrefixPath($prefix, $path, $type = null)</code></p></li>
<li><p><code class="code">addPrefixPaths(array $spec)</code></p></li>
</ul></div>
</li>
<li>
<p> 校验：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="code">addValidator($validator, $breakChainOnFailure = false, $options = array())</code></p></li>
<li><p><code class="code">addValidators(array $validators)</code></p></li>
<li><p><code class="code">setValidators(array $validators)</code></p></li>
<li><p><code class="code">getValidator($name)</code></p></li>
<li><p><code class="code">getValidators()</code></p></li>
<li><p><code class="code">removeValidator($name)</code></p></li>
<li><p><code class="code">clearValidators()</code></p></li>
<li><p><code class="code">isValid($value, $context = null)</code></p></li>
<li><p><code class="code">getErrors()</code></p></li>
<li><p><code class="code">getMessages()</code></p></li>
</ul></div>
</li>
<li>
<p> 过滤器：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="code">addFilter($filter, $options = array())</code></p></li>
<li><p><code class="code">addFilters(array $filters)</code></p></li>
<li><p><code class="code">setFilters(array $filters)</code></p></li>
<li><p><code class="code">getFilter($name)</code></p></li>
<li><p><code class="code">getFilters()</code></p></li>
<li><p><code class="code">removeFilter($name)</code></p></li>
<li><p><code class="code">clearFilters()</code></p></li>
</ul></div>
</li>
<li>
<p> 解析：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="code">setView(Zend_View_Interface $view = null)</code></p></li>
<li><p><code class="code">getView()</code></p></li>
<li><p><code class="code">addDecorator($decorator, $options = null)</code></p></li>
<li><p><code class="code">addDecorators(array $decorators)</code></p></li>
<li><p><code class="code">setDecorators(array $decorators)</code></p></li>
<li><p><code class="code">getDecorator($name)</code></p></li>
<li><p><code class="code">getDecorators()</code></p></li>
<li><p><code class="code">removeDecorator($name)</code></p></li>
<li><p><code class="code">clearDecorators()</code></p></li>
<li><p><code class="code">render(Zend_View_Interface $view = null)</code></p></li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.config"></a>23.3.8.  配置 </h3></div></div></div>
<p>
            <code class="code">Zend_Form_Element</code> 的构造器接受选项数组或包含选项的 <code class="code">Zend_Config</code> 的对象，它也可以用 <code class="code">setOptions()</code> 或 <code class="code">setConfig()</code> 来配置。一般来说，命名键如下：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                如果 'set' + 键指向 <code class="code">Zend_Form_Element</code> 方法，那么提供的值就传递给这个方法。
            </p></li>
<li><p>
                否则，这个值就用来设置属性。
            </p></li>
</ul></div>
<p>
            该规则的例外包括如下：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <code class="code">prefixPath</code> 将传递给 <code class="code">addPrefixPaths()</code>
            </p></li>
<li>
<p>
                    下面的设置器不能用这个办法：
                </p>
<div class="itemizedlist"><ul type="circle">
<li><p>
                            <code class="code">setAttrib</code> （通过 <code class="code">setAttribs</code> <span class="emphasis"><em>来工作</em></span>）
                    </p></li>
<li><p><code class="code">setConfig</code></p></li>
<li><p><code class="code">setOptions</code></p></li>
<li><p><code class="code">setPluginLoader</code></p></li>
<li><p><code class="code">setTranslator</code></p></li>
<li><p><code class="code">setView</code></p></li>
</ul></div>
</li>
</ul></div>
<p>
            这里是一个例子，为每个配置数据类型传递配置的配置文件：
        </p>
<pre class="programlisting">
[element]
name = "foo"
value = "foobar"
label = "Foo:"
order = 10
required = true
allowEmpty = false
autoInsertNotEmptyValidator = true
description = "Foo elements are for examples"
ignore = false
attribs.id = "foo"
attribs.class = "element"
onclick = "autoComplete(this, '/form/autocomplete/element')" ; sets 'onclick' attribute
prefixPaths.decorator.prefix = "My_Decorator"
prefixPaths.decorator.path = "My/Decorator/"
disableTranslator = 0
validators.required.validator = "NotEmpty"
validators.required.breakChainOnFailure = true
validators.alpha.validator = "alpha"
validators.regex.validator = "regex"
validators.regex.options.pattern = "/^[A-F].*/$"
filters.ucase.filter = "StringToUpper"
decorators.element.decorator = "ViewHelper"
decorators.element.options.helper = "FormText"
decorators.label.decorator = "Label"
</pre>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.form.elements.custom"></a>23.3.9.  定制元素 </h3></div></div></div>
<p>
            通过继承 <code class="code">Zend_Form_Element</code> 类，你可以生成自己的定制元素，这样做的原因是：
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                共享通用的校验器和/或过滤器的元素
            </p></li>
<li><p>
                有定制装饰器功能的元素
            </p></li>
</ul></div>
<p>
            有两个方法一般用来扩展元素：<code class="code">init()</code> 可为元素添加定制的初始化逻辑；<code class="code">loadDefaultDecorators()</code> 可用于设置一个用于元素的缺省装饰器的列表。
        </p>
<p>
            用例子来说明，你在一个表单里生成的所有文本元素需要用 <code class="code">StringTrim</code> 来过滤、用通用的规则表达式来校验，并且你想用你生成的定制的装饰器来显示它们，'My_Decorator_TextItem'。另外，你有许多想指定的标准属性，包括 'size'、 'maxLength' 和 'class'。你可以定义这样的元素如下：
        </p>
<pre class="programlisting">&lt;?php
class My_Element_Text extends Zend_Form_Element
{
    public function init()
    {
        $this-&gt;addPrefixPath('My_Decorator', 'My/Decorator/', 'decorator')
             -&gt;addFilters('StringTrim')
             -&gt;addValidator('Regex', false, array('/^[a-z0-9]{6,}$/i'))
             -&gt;addDecorator('TextItem')
             -&gt;setAttrib('size', 30)
             -&gt;setAttrib('maxLength', 45)
             -&gt;setAttrib('class', 'text');
    }
}
?&gt;</pre>
<p>
            你接着可以通知表单对象关于元素的前缀路径并开始生成元素：
        </p>
<pre class="programlisting">&lt;?php
$form-&gt;addPrefixPath('My_Element', 'My/Element/', 'element')
     -&gt;addElement('foo', 'text');
?&gt;</pre>
<p>
            'foo' 元素现在是 <code class="code">My_Element_Text</code> 类型并展示你描画的行为。
        </p>
<p>
            当继承 <code class="code">Zend_Form_Element</code> 时你想 override 的另一个特殊方法是 <code class="code">loadDefaultDecorators()</code>。这个方法有条件地为你的元素加载一组缺省装饰器，你可能想在你的继承类里替换你自己的装饰器。
        </p>
<pre class="programlisting">&lt;?php
class My_Element_Text extends Zend_Form_Element
{
    public function loadDefaultDecorators()
    {
        $this-&gt;addDecorator('ViewHelper')
             -&gt;addDecorator('DisplayError')
             -&gt;addDecorator('Label')
             -&gt;addDecorator('HtmlTag', array('tag' =&gt; 'div', 'class' =&gt; 'element'));
    }
}
?&gt;</pre>
<p>
            有许多办法定制元素。别忘了阅读  <code class="code">Zend_Form_Element</code> API 文档来获知所有的可用方法。
        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.form.quickstart.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.form.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.form.forms.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">23.2. Zend_Form 快速起步  </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 23.4.  使用 Zend_Form 生成表单 </td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
