<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>39.4. Advanced usage</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Zend Framework手册 中文版">
<link rel="up" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="prev" href="zend.paginator.configuration.html" title="39.3. Configuration">
<link rel="next" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="introduction.html" title="第 1 章 Zend Framework简介">
<link rel="chapter" href="zend.acl.html" title="第 2 章 Zend_Acl">
<link rel="chapter" href="zend.amf.html" title="第 3 章 Zend_Amf">
<link rel="chapter" href="zend.application.html" title="第 4 章 Zend_Application">
<link rel="chapter" href="zend.auth.html" title="第 5 章 Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="第 6 章 Zend_Cache">
<link rel="chapter" href="zend.captcha.html" title="第 7 章 Zend_Captcha">
<link rel="chapter" href="zend.codegenerator.html" title="第 8 章 Zend_CodeGenerator">
<link rel="chapter" href="zend.config.html" title="第 9 章 Zend_Config">
<link rel="chapter" href="zend.config.writer.html" title="第 10 章 Zend_Config_Writer">
<link rel="chapter" href="zend.console.getopt.html" title="第 11 章 Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="第 12 章 Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="第 13 章 Zend_Currency">
<link rel="chapter" href="zend.date.html" title="第 14 章 Zend_Date">
<link rel="chapter" href="zend.db.html" title="第 15 章 Zend_Db">
<link rel="chapter" href="zend.debug.html" title="第 16 章 Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="第 17 章 Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="第 18 章 Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="第 19 章 Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="第 20 章 Zend_Feed">
<link rel="chapter" href="zend.file.html" title="第 21 章 Zend_File">
<link rel="chapter" href="zend.filter.html" title="第 22 章 Zend_Filter">
<link rel="chapter" href="zend.form.html" title="第 23 章 Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="第 24 章 Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="第 25 章 Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="第 26 章 Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="第 27 章 Zend_Json">
<link rel="chapter" href="zend.layout.html" title="第 28 章 Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="第 29 章 Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="第 30 章 Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="第 31 章 Zend_Locale">
<link rel="chapter" href="zend.log.html" title="第 32 章 Zend_Log">
<link rel="chapter" href="zend.mail.html" title="第 33 章 Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="第 34 章 Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="第 35 章 Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="第 36 章 Zend_Mime">
<link rel="chapter" href="zend.navigation.html" title="第 37 章 Zend_Navigation">
<link rel="chapter" href="zend.openid.html" title="第 38 章 Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="第 39 章 Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="第 40 章 Zend_Pdf">
<link rel="chapter" href="zend.progressbar.html" title="第 41 章 Zend_ProgressBar">
<link rel="chapter" href="zend.queue.html" title="第 42 章 Zend_Queue">
<link rel="chapter" href="zend.reflection.html" title="第 43 章 Zend_Reflection">
<link rel="chapter" href="zend.registry.html" title="第 44 章 Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="第 45 章 Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="第 46 章 Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="第 47 章 Zend_Server">
<link rel="chapter" href="zend.service.html" title="第 48 章 Zend_Service">
<link rel="chapter" href="zend.session.html" title="第 49 章 Zend_Session">
<link rel="chapter" href="zend.soap.html" title="第 50 章 Zend_Soap">
<link rel="chapter" href="zend.tag.html" title="第 51 章 Zend_Tag">
<link rel="chapter" href="zend.test.html" title="第 52 章 Zend_Test">
<link rel="chapter" href="zend.text.html" title="第 53 章 Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="第 54 章 Zend_TimeSync">
<link rel="chapter" href="zend.tool.framework.html" title="第 55 章 Zend_Tool_Framework">
<link rel="chapter" href="zend.tool.project.html" title="第 56 章 Zend_Tool_Project">
<link rel="chapter" href="zend.translate.html" title="第 57 章 Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="第 58 章 Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="第 59 章 Zend_Validate">
<link rel="chapter" href="zend.version.html" title="第 60 章 Zend_Version">
<link rel="chapter" href="zend.view.html" title="第 61 章 Zend_View">
<link rel="chapter" href="zend.wildfire.html" title="第 62 章 Zend_Wildfire">
<link rel="chapter" href="zend.xmlrpc.html" title="第 63 章 Zend_XmlRpc">
<link rel="chapter" href="zendx.console.process.unix.html" title="第 64 章 ZendX_Console_Process_Unix">
<link rel="chapter" href="zendx.jquery.html" title="第 65 章 ZendX_JQuery">
<link rel="appendix" href="requirements.html" title="附录 A. 系统需求">
<link rel="appendix" href="coding-standard.html" title="附录 B. Zend Framework 的 PHP 编码标准">
<link rel="appendix" href="doc-standard.html" title="附录 C. Zend Framework Documentation Standard">
<link rel="appendix" href="project-structure.html" title="附录 D. Recommended Project Structure for Zend Framework MVC Applications">
<link rel="appendix" href="performance.html" title="附录 E. Zend Framework Performance Guide">
<link rel="appendix" href="copyrights.html" title="附录 F. 版权信息">
<link rel="index" href="the.index.html" title="索引">
<link rel="subsection" href="zend.paginator.advanced.html#zend.paginator.advanced.adapters" title="39.4.1. Custom data source adapters">
<link rel="subsection" href="zend.paginator.advanced.html#zend.paginator.advanced.scrolling-styles" title="39.4.2. Custom scrolling styles">
<link rel="subsection" href="zend.paginator.advanced.html#zend.paginator.advanced.caching" title="39.4.3. Caching features">
<link rel="subsection" href="zend.paginator.advanced.html#zend.paginator.advanced.aggregator" title="39.4.4. Zend_Paginator_AdapterAggregate Interface">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">39.4. Advanced usage</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.paginator.configuration.html">上一页</a> </td>
<th width="60%" align="center">第 39 章 Zend_Paginator</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.pdf.html">下一页</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.paginator.advanced"></a>39.4. Advanced usage</h2></div></div></div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.paginator.advanced.adapters"></a>39.4.1. Custom data source adapters</h3></div></div></div>
<p>
            At some point you may run across a data type that is not covered by
            the packaged adapters. In this case, you will need to write your
            own.
        </p>
<p>
            To do so, you must implement
            <code class="classname">Zend_Paginator_Adapter_Interface</code>. There are two
            methods required to do this:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>count()</p></li>
<li><p>getItems($offset, $itemCountPerPage)</p></li>
</ul></div>
<p>
            Additionally, you'll want to implement a constructor that takes
            your data source as a parameter and stores it as a protected or
            private property. How you wish to go about doing this
            specifically is up to you.
        </p>
<p>
            If you've ever used the SPL interface
            <a href="http://www.php.net/~helly/php/ext/spl/interfaceCountable.html" target="_top"><code class="code">Countable</code></a>,
            you're familiar with <code class="methodname">count()</code>. As used with
            <code class="classname">Zend_Paginator</code>, this is the total number of items
            in the data collection.
            Additionally, the <code class="classname">Zend_Paginator</code> instance provides a method
            <code class="methodname">countAllItems()</code> that proxies to the adapter
            <code class="methodname">count()</code> method.
        </p>
<p>
            The <code class="methodname">getItems()</code> method is only slightly more
            complicated. For this, your adapter is supplied with an offset and
            the number of items to display per page. You must return the
            appropriate slice of data. For an array, that would be:
        </p>
<p>
            </p>
<pre class="programlisting">
return array_slice($this-&gt;_array, $offset, $itemCountPerPage);
</pre>
<p>
        </p>
<p>
            Take a look at the packaged adapters (all of which implement the
            <code class="classname">Zend_Paginator_Adapter_Interface</code>) for ideas of how you
            might go about implementing your own.
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.paginator.advanced.scrolling-styles"></a>39.4.2. Custom scrolling styles</h3></div></div></div>
<p>
            Creating your own scrolling style requires that you implement
            <code class="classname">Zend_Paginator_ScrollingStyle_Interface</code>, which defines
            a single method, <code class="methodname">getPages()</code>. Specifically,
        </p>
<p>
            </p>
<pre class="programlisting">
public function getPages(Zend_Paginator $paginator, $pageRange = null);
</pre>
<p>
        </p>
<p>
            This method should calculate a lower and upper bound for page
            numbers within the range of so-called "local" pages (that is, pages
            that are nearby the current page).
        </p>
<p>
            Unless it extends another scrolling style (see
            <code class="classname">Zend_Paginator_ScrollingStyle_Elastic</code> for an example),
            your custom scrolling style will inevitably end with something
            similar to the following line of code:
        </p>
<p>
            </p>
<pre class="programlisting">
return $paginator-&gt;getPagesInRange($lowerBound, $upperBound);
</pre>
<p>
        </p>
<p>
            There's nothing special about this call; it's merely a convenience
            method to check the validity of the lower and upper bound and
            return an array of the range to the paginator.
        </p>
<p>
            When you're ready to use your new scrolling style, you'll need to
            tell <code class="classname">Zend_Paginator</code> what directory to look in. To do
            that, do the following:
        </p>
<p>
            </p>
<pre class="programlisting">
$prefix = 'My_Paginator_ScrollingStyle';
$path   = 'My/Paginator/ScrollingStyle/';
Zend_Paginator::addScrollingStylePrefixPath($prefix, $path);
</pre>
<p>
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.paginator.advanced.caching"></a>39.4.3. Caching features</h3></div></div></div>
<p>
            <code class="classname">Zend_Paginator</code> can be told to cache the data it has already
            passed on, preventing the adapter from fetching them each time they are used.
            To tell paginator to automatically cache the adapter's data, just pass to
            its <code class="methodname">setCache()</code> method a <code class="classname">Zend_Cache_Core</code> instance.
        </p>
<p>
            </p>
<pre class="programlisting">
$paginator = Zend_Paginator::factory($someData);
$fO = array('lifetime' =&gt; 3600, 'automatic_serialization' =&gt; true);
$bO = array('cache_dir'=&gt;'/tmp');
$cache = Zend_cache::factory('Core', 'File', $fO, $bO);
Zend_Paginator::setCache($cache);
</pre>
<p>
        </p>
<p>
            As far as <code class="classname">Zend_Paginator</code> has got a <code class="classname">Zend_Cache_Core</code> instance, data will
            be cached. Sometimes you would like not to cache data even if you already passed
            a cache instance. You should then use <code class="methodname">setCacheEnable()</code> for that.
        </p>
<p>
            </p>
<pre class="programlisting">
$paginator = Zend_Paginator::factory($someData);
// $cache is a Zend_Cache_Core instance
Zend_Paginator::setCache($cache);
// ... later on the script
$paginator-&gt;setCacheEnable(false);
// cache is now disabled
</pre>
<p>
        </p>
<p>
            When a cache is set, data are automatically stored in it and pulled out from
            it. It then can be useful to empty the cache manually. You can get this done by
            calling <code class="methodname">clearPageItemCache($pageNumber)</code>.
            If you don't pass any parameter, the whole cache will be empty. You can optionally
            pass a parameter representing the page number to empty in the cache:
        </p>
<p>
            </p>
<pre class="programlisting">
$paginator = Zend_Paginator::factory($someData);
Zend_Paginator::setCache($cache);
$items = $paginator-&gt;getCurrentItems();
// page 1 is now in cache
$page3Items = $paginator-&gt;getItemsByPage(3);
// page 3 is now in cache

// clear the cache of the results for page 3
$paginator-&gt;clearPageItemCache(3);

// clear all the cache data
$paginator-&gt;clearPageItemCache();
</pre>
<p>
        </p>
<p>
            Changing the item count per page will empty the whole cache
            as it would have become invalid:
        </p>
<p>
            </p>
<pre class="programlisting">
$paginator = Zend_Paginator::factory($someData);
Zend_Paginator::setCache($cache);
// fetch some items
$items = $paginator-&gt;getCurrentItems();

// all the cache data will be flushed:
$paginator-&gt;setItemCountPerPage(2);
</pre>
<p>
        </p>
<p>
            It is also possible to see the data in cache and ask for them directly.
            <code class="methodname">getPageItemCache()</code> can be used for that:
        </p>
<p>
            </p>
<pre class="programlisting">
$paginator = Zend_Paginator::factory($someData);
$paginator-&gt;setItemCountPerPage(3);
Zend_Paginator::setCache($cache);

// fetch some items
$items = $paginator-&gt;getCurrentItems();
$otherItems = $paginator-&gt;getItemsPerPage(4);

// see the cached items as a two-dimension array:
var_dump($paginator-&gt;getPageItemCache());
</pre>
<p>
        </p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.paginator.advanced.aggregator"></a>39.4.4. Zend_Paginator_AdapterAggregate Interface</h3></div></div></div>
<p>
            Depending on your application you might want to paginate objects, whose internal data-structure
            is equal to existing adapters, but you don't want to break up your encapsulation to allow access
            to this data. In other cases an object might be in a "has-an adapter" relationship, rather than
            the "is-an adapter" relationsship that <code class="classname">Zend_Paginator_Adapter_Abstract</code> promotes.
            For this cases you can use the <code class="classname">Zend_Paginator_AdapterAggregate</code> interface that
            behaves much like the <code class="classname">IteratorAggregate</code> interface of the PHP SPL extension.
        </p>
<p>
            </p>
<pre class="programlisting">
interface Zend_Paginator_AdapterAggregate
{
    /**
     * Return a fully configured Paginator Adapter from this method.
     *
     * @return Zend_Paginator_Adapter_Abstract
     */
    public function getPaginatorAdapter();
}
</pre>
<p>
        </p>
<p>
            The interface is fairly small and only expects you to return an instance of
            <code class="classname">Zend_Paginator_Adapter_Abstract</code>. An Adapter Aggregate instance is then
            recognized by both <code class="code">Zend_Paginator::factory</code> and the constructor of Zend_Paginator and
            handled accordingly.
        </p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.paginator.configuration.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.paginator.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.pdf.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">39.3. Configuration </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 第 40 章 Zend_Pdf</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
